<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>包里装着个卡比兽</title><link>https://Z-Xiao-M.github.io/github.io</link><description>待会去码头整点薯条🍟</description><copyright>包里装着个卡比兽</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://z-xiao-m.github.io/github.io/avatar.svg</url><title>avatar</title><link>https://Z-Xiao-M.github.io/github.io</link></image><lastBuildDate>Fri, 05 Sep 2025 16:15:46 +0000</lastBuildDate><managingEditor>包里装着个卡比兽</managingEditor><ttl>60</ttl><webMaster>包里装着个卡比兽</webMaster><item><title>pg_uprobe——不需要修改任何代码，就可以观测内核C函数执行时间</title><link>https://Z-Xiao-M.github.io/github.io/post/pg_uprobe%E2%80%94%E2%80%94%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BF%AE%E6%94%B9%E4%BB%BB%E4%BD%95%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%A7%82%E6%B5%8B%E5%86%85%E6%A0%B8C%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4.html</link><description># 前言
之前在看ebpf的时候，了解到了kprobe （内核态探针）和 uprobe （用户态探针）。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/pg_uprobe%E2%80%94%E2%80%94%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BF%AE%E6%94%B9%E4%BB%BB%E4%BD%95%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%A7%82%E6%B5%8B%E5%86%85%E6%A0%B8C%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4.html</guid><pubDate>Thu, 04 Sep 2025 10:25:58 +0000</pubDate></item><item><title>plpgsql中的隐式子事务</title><link>https://Z-Xiao-M.github.io/github.io/post/plpgsql%E4%B8%AD%E7%9A%84%E9%9A%90%E5%BC%8F%E5%AD%90%E4%BA%8B%E5%8A%A1.html</link><description>在事务块中调用存在异常的函数

```sql
CREATE TABLE tmp(id int);

CREATE OR REPLACE FUNCTION demo_plpgsql_subxact()
RETURNS void AS $$
BEGIN                        
    INSERT INTO tmp VALUES (-2);
    INSERT INTO tmp VALUES (1/0);  -- error
EXCEPTION
    WHEN division_by_zero THEN
        RAISE INFO '%', SQLERRM;
        INSERT INTO tmp VALUES (-3);            
END;
$$ LANGUAGE plpgsql;

BEGIN; -- 开启事务
INSERT INTO tmp VALUES (-1);
ELECT demo_plpgsql_subxact(); -- 调用函数
select * from tmp;
COMMIT;

truncate tmp;

-- 等价于
BEGIN; -- 开启事务
INSERT INTO tmp VALUES (-1);
SAVEPOINT exception;  -- 保存点
INSERT INTO tmp VALUES (-2);
INSERT INTO tmp VALUES (1/0);  -- error
ROLLBACK TO SAVEPOINT exception; -- 异常回滚到保存点
INSERT INTO tmp VALUES (-3); 
SELECT * FROM tmp;
COMMIT;
```

运行结果

```sql
postgres@zxm-VMware-Virtual-Platform:~$ psql
psql (16.10)
Type 'help' for help.

postgres=# CREATE TABLE tmp(id int);
CREATE TABLE
postgres=# CREATE OR REPLACE FUNCTION demo_plpgsql_subxact()
postgres-# RETURNS void AS $$
postgres$# BEGIN  
postgres$#     INSERT INTO tmp VALUES (-2);
postgres$#     INSERT INTO tmp VALUES (1/0);  -- error
postgres$# EXCEPTION
postgres$#     WHEN division_by_zero THEN
postgres$#                 RAISE INFO '%', SQLERRM;
postgres$#         INSERT INTO tmp VALUES (-3); 
postgres$# END;
postgres$# $$ LANGUAGE plpgsql;
CREATE FUNCTION
postgres=# BEGIN;
BEGIN
postgres=*# INSERT INTO tmp VALUES (-1);
INSERT 0 1
postgres=*# SELECT demo_plpgsql_subxact(); -- 调用函数
INFO:  division by zero
 demo_plpgsql_subxact 
----------------------
 
(1 row)

postgres=*# select * from tmp;
 id 
----
 -1
 -3
(2 rows)

postgres=*# COMMIT;
COMMIT
postgres=# truncate tmp;
TRUNCATE TABLE
postgres=# BEGIN;
BEGIN
postgres=*# INSERT INTO tmp VALUES (-1);
INSERT 0 1
postgres=*# SAVEPOINT exception;
SAVEPOINT
postgres=*# INSERT INTO tmp VALUES (-2);
INSERT 0 1
postgres=*# INSERT INTO tmp VALUES (1/0);  -- error
ERROR:  division by zero
postgres=!# ROLLBACK TO SAVEPOINT exception;
ROLLBACK
postgres=*# INSERT INTO tmp VALUES (-3); 
INSERT 0 1
postgres=*# COMMIT;
COMMIT
postgres=# SELECT * FROM tmp;
 id 
----
 -1
 -3
(2 rows)

postgres=# 
```

在事务块中，调用不存在异常的函数

```sql
TRUNCATE tmp;

CREATE OR REPLACE FUNCTION demo_plpgsql_subxact()
RETURNS void AS $$
BEGIN                        
    INSERT INTO tmp VALUES (-2);
    INSERT INTO tmp VALUES (-3);
EXCEPTION
    WHEN division_by_zero THEN
        RAISE INFO '%', SQLERRM;        
END;
$$ LANGUAGE plpgsql;

BEGIN; -- 开启事务块
INSERT INTO tmp VALUES (-1);
select demo_plpgsql_subxact();
INSERT INTO tmp VALUES (-4);
SELECT * FROM tmp;
COMMIT;


TRUNCATE tmp;
-- 等价于
BEGIN; -- 开启事务块
INSERT INTO tmp VALUES (-1);
SAVEPOINT exception;
INSERT INTO tmp VALUES (-2);
INSERT INTO tmp VALUES (-3);
RELEASE SAVEPOINT exception;
INSERT INTO tmp VALUES (-4);
SELECT * FROM tmp;
COMMIT;
```

运行结果

```sql
postgres@zxm-VMware-Virtual-Platform:~$ psql
psql (16.10)
Type 'help' for help.

postgres=# TRUNCATE tmp;
TRUNCATE TABLE
postgres=# CREATE OR REPLACE FUNCTION demo_plpgsql_subxact()
RETURNS void AS $$
BEGIN                        
    INSERT INTO tmp VALUES (-2);
    INSERT INTO tmp VALUES (-3);
EXCEPTION
    WHEN division_by_zero THEN
        RAISE INFO '%', SQLERRM;        
END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION
postgres=# BEGIN; -- 开启事务块
BEGIN
postgres=*# INSERT INTO tmp VALUES (-1);
INSERT 0 1
postgres=*# select demo_plpgsql_subxact();
 demo_plpgsql_subxact 
----------------------
 
(1 row)

postgres=*# INSERT INTO tmp VALUES (-4);
INSERT 0 1
postgres=*# SELECT * FROM tmp;
 id 
----
 -1
 -2
 -3
 -4
(4 rows)

postgres=*# COMMIT;
COMMIT
postgres=# TRUNCATE tmp;
TRUNCATE TABLE
postgres=# -- 等价于
postgres=# BEGIN; -- 开启事务块
BEGIN
postgres=*# INSERT INTO tmp VALUES (-1);
INSERT 0 1
postgres=*# SAVEPOINT exception; -- 开启子事务
SAVEPOINT
postgres=*# INSERT INTO tmp VALUES (-2);
INSERT 0 1
postgres=*# INSERT INTO tmp VALUES (-3);
INSERT 0 1
postgres=*# RELEASE SAVEPOINT exception;
RELEASE
postgres=*# INSERT INTO tmp VALUES (-4);
INSERT 0 1
postgres=*# SELECT * FROM tmp;
 id 
----
 -1
 -2
 -3
 -4
(4 rows)

postgres=*# COMMIT;
COMMIT
postgres=# 
```

没有exception则不会触发子事务的动作，部分`exec_stmt_block`代码片段如下
```c
static int
exec_stmt_block(PLpgSQL_execstate *estate, PLpgSQL_stmt_block *block)
{
  // initialize 
  if (block-&gt;exceptions)
  {
    BeginInternalSubTransaction(NULL);  // 开启子事务

    PG_TRY();
    {
      /* Run the block's statements */
      rc = exec_stmts(estate, block-&gt;body); // 执行相关操作

      /* Commit the inner transaction, return to outer xact context */
      ReleaseCurrentSubTransaction(); // 释放子事务
    }
    PG_CATCH();
    {

      /* Abort the inner transaction */
      RollbackAndReleaseCurrentSubTransaction(); // 发生了异常回滚子事务

      // 异常匹配和处理
      foreach(e, block-&gt;exceptions-&gt;exc_list)
      {
        PLpgSQL_exception *exception = (PLpgSQL_exception *) lfirst(e);
        if (exception_matches_conditions(edata, exception-&gt;conditions))
        {
          rc = exec_stmts(estate, exception-&gt;action); // exception块中的其余操作
          break;
        }
      }
    }
    PG_END_TRY();
  }
  else
  {
    /*
     * Just execute the statements in the block's body
     */
    estate-&gt;err_text = NULL;
    // 没有exception块 执行此处 不会开启子事务
    rc = exec_stmts(estate, block-&gt;body);
  }
  // ...
}
``` 。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/plpgsql%E4%B8%AD%E7%9A%84%E9%9A%90%E5%BC%8F%E5%AD%90%E4%BA%8B%E5%8A%A1.html</guid><pubDate>Thu, 04 Sep 2025 07:35:19 +0000</pubDate></item><item><title>文摘: 如果没有人读博客，为什么要写呢？</title><link>https://Z-Xiao-M.github.io/github.io/post/%E6%96%87%E6%91%98--%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E4%BA%BA%E8%AF%BB%E5%8D%9A%E5%AE%A2%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%91%A2%EF%BC%9F.html</link><description>&gt; 我偶然看到这么一段话，想简单记录一下

让我们坦率一点吧，你写了一篇博客，根本就没有人读。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/%E6%96%87%E6%91%98--%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E4%BA%BA%E8%AF%BB%E5%8D%9A%E5%AE%A2%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%91%A2%EF%BC%9F.html</guid><pubDate>Thu, 04 Sep 2025 05:40:35 +0000</pubDate></item><item><title>查询耗时同临时表的数量呈线性增长</title><link>https://Z-Xiao-M.github.io/github.io/post/%E6%9F%A5%E8%AF%A2%E8%80%97%E6%97%B6%E5%90%8C%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%9A%84%E6%95%B0%E9%87%8F%E5%91%88%E7%BA%BF%E6%80%A7%E5%A2%9E%E9%95%BF.html</link><description>内容演示：
```sql
postgres@zxm-VMware-Virtual-Platform:~/code/16$ psql -o /dev/null
psql (16.10)
Type 'help' for help.

postgres=# \timing
Timing is on.
postgres=# select * from pg_database;
Time: 0.491 ms
postgres=# select * from pg_database;
Time: 0.676 ms
postgres=# select * from pg_database;
Time: 0.573 ms
postgres=# CREATE TEMP TABLE a_gtt (n numeric) ON COMMIT DELETE ROWS;
Time: 5.771 ms
postgres=# select * from a_gtt;
Time: 1.721 ms
postgres=# select * from a_gtt;
Time: 1.383 ms
postgres=# select * from a_gtt;
Time: 1.703 ms
postgres=# DO $$
DECLARE
  v_sql VARCHAR(100);
BEGIN
  FOR i IN 1..3000 LOOP
    v_sql := 'CREATE TEMP TABLE a_gtt'||i||'(n numeric) ON COMMIT DELETE ROWS';
    EXECUTE v_sql;
  END LOOP;
END;
$$ LANGUAGE plpgsql;
Time: 4150.059 ms (00:04.150)
postgres=# select * from a_gtt;
Time: 1250.611 ms (00:01.251)
postgres=# select * from a_gtt;
Time: 1239.305 ms (00:01.239)
postgres=# select * from a_gtt;
Time: 1213.000 ms (00:01.213)
postgres=# select * from pg_database;
Time: 1.975 ms
postgres=# select * from pg_database;
Time: 0.981 ms
postgres=# select * from pg_database;
Time: 0.758 ms
```
粗略的判断，没有仔细研究，估计原因在于需要多次遍历大的list，以及还需要对临时表做一些额外的清理工作
```c
// 和on_commits 息息相关
static List *on_commits = NIL;
```
在创建临时表时，如果存在ON COMMIT的动作 就会将其动作注册到这个变量中
```c
/* What to do at commit time for temporary relations */
typedef enum OnCommitAction
{
	ONCOMMIT_NOOP,				/* No ON COMMIT clause (do nothing) */
	ONCOMMIT_PRESERVE_ROWS,		/* ON COMMIT PRESERVE ROWS (do nothing) */
	ONCOMMIT_DELETE_ROWS,		/* ON COMMIT DELETE ROWS */
	ONCOMMIT_DROP				/* ON COMMIT DROP */
} OnCommitAction;


// heap_create_with_catalog
	 * If there's a special on-commit action, remember it
	 */
	if (oncommit != ONCOMMIT_NOOP)
		register_on_commit_action(relid, oncommit);

/*
 * Register a newly-created relation's ON COMMIT action.
 */
void
register_on_commit_action(Oid relid, OnCommitAction action)
{
	OnCommitItem *oc;
	MemoryContext oldcxt;

	/*
	 * We needn't bother registering the relation unless there is an ON COMMIT
	 * action we need to take.
	 */
	if (action == ONCOMMIT_NOOP || action == ONCOMMIT_PRESERVE_ROWS)
		return;

	oldcxt = MemoryContextSwitchTo(CacheMemoryContext);

	oc = (OnCommitItem *) palloc(sizeof(OnCommitItem));
	oc-&gt;relid = relid;
	oc-&gt;oncommit = action;
	oc-&gt;creating_subid = GetCurrentSubTransactionId();
	oc-&gt;deleting_subid = InvalidSubTransactionId;

	/*
	 * We use lcons() here so that ON COMMIT actions are processed in reverse
	 * order of registration.  That might not be essential but it seems
	 * reasonable.
	 */
	on_commits = lcons(oc, on_commits);

	MemoryContextSwitchTo(oldcxt);
}
```
而在事务将要完成之前，需要处理这个list中的相关内容
```c
/*
 * Perform ON COMMIT actions.
 *
 * This is invoked just before actually committing, since it's possible
 * to encounter errors.
 */
void
PreCommit_on_commit_actions(void)
{
	ListCell   *l;
	List	   *oids_to_truncate = NIL;
	List	   *oids_to_drop = NIL;

         // 遍历
	foreach(l, on_commits)
	{
		OnCommitItem *oc = (OnCommitItem *) lfirst(l);

		/* Ignore entry if already dropped in this xact */
		if (oc-&gt;deleting_subid != InvalidSubTransactionId)
			continue;

		switch (oc-&gt;oncommit)
		{
			case ONCOMMIT_NOOP:
			case ONCOMMIT_PRESERVE_ROWS:
				/* Do nothing (there shouldn't be such entries, actually) */
				break;
			case ONCOMMIT_DELETE_ROWS:

				/*
				 * If this transaction hasn't accessed any temporary
				 * relations, we can skip truncating ON COMMIT DELETE ROWS
				 * tables, as they must still be empty.
				 */
				if ((MyXactFlags &amp; XACT_FLAGS_ACCESSEDTEMPNAMESPACE))
					oids_to_truncate = lappend_oid(oids_to_truncate, oc-&gt;relid); // 生成新的list
				break;
			case ONCOMMIT_DROP:
				oids_to_drop = lappend_oid(oids_to_drop, oc-&gt;relid);
				break;
		}
	}

	/*
	 * Truncate relations before dropping so that all dependencies between
	 * relations are removed after they are worked on.  Doing it like this
	 * might be a waste as it is possible that a relation being truncated will
	 * be dropped anyway due to its parent being dropped, but this makes the
	 * code more robust because of not having to re-check that the relation
	 * exists at truncation time.
	 */
	if (oids_to_truncate != NIL)
		heap_truncate(oids_to_truncate); // 新的list需要处理

	if (oids_to_drop != NIL)
	{
		ObjectAddresses *targetObjects = new_object_addresses();

		foreach(l, oids_to_drop)
		{
			ObjectAddress object;

			object.classId = RelationRelationId;
			object.objectId = lfirst_oid(l);
			object.objectSubId = 0;

			Assert(!object_address_present(&amp;object, targetObjects));

			add_exact_object_address(&amp;object, targetObjects);
		}

		/*
		 * Object deletion might involve toast table access (to clean up
		 * toasted catalog entries), so ensure we have a valid snapshot.
		 */
		PushActiveSnapshot(GetTransactionSnapshot());

		/*
		 * Since this is an automatic drop, rather than one directly initiated
		 * by the user, we pass the PERFORM_DELETION_INTERNAL flag.
		 */
		performMultipleDeletions(targetObjects, DROP_CASCADE,
								 PERFORM_DELETION_INTERNAL | PERFORM_DELETION_QUIETLY);

		PopActiveSnapshot();

#ifdef USE_ASSERT_CHECKING

		/*
		 * Note that table deletion will call remove_on_commit_action, so the
		 * entry should get marked as deleted.
		 */
		foreach(l, on_commits)
		{
			OnCommitItem *oc = (OnCommitItem *) lfirst(l);

			if (oc-&gt;oncommit != ONCOMMIT_DROP)
				continue;

			Assert(oc-&gt;deleting_subid != InvalidSubTransactionId);
		}
#endif
	}
}
``` 
调试可以看到：
&lt;img width='1062' height='1040' alt='Image' src='https://github.com/user-attachments/assets/8e0198e4-ef63-47a3-96f3-7b8399fac7d2' /&gt;

其实主要耗时应该还是`heap_truncate`
```c
void
heap_truncate(List *relids)
{
	List	   *relations = NIL;
	ListCell   *cell;

        // 遍历
	/* Open relations for processing, and grab exclusive access on each */
	foreach(cell, relids)
	{
		Oid			rid = lfirst_oid(cell);
		Relation	rel;

		rel = table_open(rid, AccessExclusiveLock);
		relations = lappend(relations, rel);  // 生成新的list
	}

	/* Don't allow truncate on tables that are referenced by foreign keys */
	heap_truncate_check_FKs(relations, true); // 其实这内部还有遍历

        // 再次遍历
	/* OK to do it */
	foreach(cell, relations)
	{
		Relation	rel = lfirst(cell);

		/* Truncate the relation */
		heap_truncate_one_rel(rel);  // 估计大部分的耗时在此处

		/* Close the relation, but keep exclusive lock on it until commit */
		table_close(rel, NoLock);
	}
}
```
调试可以看到：
&lt;img width='1011' height='766' alt='Image' src='https://github.com/user-attachments/assets/8bcde450-2946-43ef-8db6-d67742f15338' /&gt;


heap_truncate_check_FKs中还存在遍历，调试可以看到：
&lt;img width='1038' height='478' alt='Image' src='https://github.com/user-attachments/assets/6db8a667-7d7d-4988-8873-48f9657627bb' /&gt;

加了些打印，看的更清楚一些

```sql
postgres@zxm-VMware-Virtual-Platform:~/code/16$ psql -o /dev/null
INFO:  PreCommit_on_commit_actions time: 0.000 ms

psql (16.10)
Type 'help' for help.

postgres=# \timing
Timing is on.
postgres=# select * from pg_database;
INFO:  PreCommit_on_commit_actions time: 0.000 ms

Time: 1.724 ms
postgres=# select * from pg_database;
INFO:  PreCommit_on_commit_actions time: 0.000 ms

Time: 0.636 ms
postgres=# select * from pg_database;
INFO:  PreCommit_on_commit_actions time: 0.000 ms

Time: 0.634 ms
postgres=# CREATE TEMP TABLE a_gtt (n numeric) ON COMMIT DELETE ROWS;
INFO:  heap_truncate time: 0.534 ms

INFO:  PreCommit_on_commit_actions time: 0.618 ms

Time: 16.613 ms
postgres=# select * from a_gtt;
INFO:  heap_truncate time: 0.756 ms

INFO:  PreCommit_on_commit_actions time: 0.834 ms

Time: 2.341 ms
postgres=# select * from a_gtt;
INFO:  heap_truncate time: 0.727 ms

INFO:  PreCommit_on_commit_actions time: 0.789 ms

Time: 1.372 ms
postgres=# select * from a_gtt;
INFO:  heap_truncate time: 0.838 ms

INFO:  PreCommit_on_commit_actions time: 0.918 ms

Time: 1.746 ms
postgres=# DO $$
DECLARE
  v_sql VARCHAR(100);
BEGIN
  FOR i IN 1..3000 LOOP
    v_sql := 'CREATE TEMP TABLE a_gtt'||i||'(n numeric) ON COMMIT DELETE ROWS';
    EXECUTE v_sql;
  END LOOP;
END;
$$ LANGUAGE plpgsql;
INFO:  heap_truncate time: 1048.421 ms

INFO:  PreCommit_on_commit_actions time: 1048.570 ms

Time: 3854.843 ms (00:03.855)
postgres=# select * from a_gtt;
INFO:  PreCommit_on_commit_actions time: 0.053 ms

INFO:  heap_truncate time: 1234.707 ms

INFO:  PreCommit_on_commit_actions time: 1234.880 ms

Time: 1242.413 ms (00:01.242)
postgres=# select * from a_gtt;
INFO:  PreCommit_on_commit_actions time: 0.039 ms

INFO:  heap_truncate time: 1199.870 ms

INFO:  PreCommit_on_commit_actions time: 1200.038 ms

Time: 1207.323 ms (00:01.207)
postgres=# select * from a_gtt;
INFO:  PreCommit_on_commit_actions time: 0.038 ms

INFO:  heap_truncate time: 1384.979 ms

INFO:  PreCommit_on_commit_actions time: 1385.284 ms

Time: 1393.626 ms (00:01.394)
postgres=# select * from pg_database;
INFO:  PreCommit_on_commit_actions time: 0.063 ms

INFO:  PreCommit_on_commit_actions time: 0.092 ms

Time: 2.293 ms
postgres=# select * from pg_database;
INFO:  PreCommit_on_commit_actions time: 0.111 ms

Time: 0.963 ms
postgres=# select * from pg_database;
INFO:  PreCommit_on_commit_actions time: 0.103 ms

Time: 0.933 ms
postgres=# 
```
没修改什么代码
```c
diff --git a/src/backend/catalog/heap.c b/src/backend/catalog/heap.c
index e67ffc37b7d..d3d85cb1264 100644
--- a/src/backend/catalog/heap.c
+++ b/src/backend/catalog/heap.c
@@ -75,6 +75,7 @@
 #include 'utils/lsyscache.h'
 #include 'utils/syscache.h'
 
+#include 'portability/instr_time.h'
 
 /* Potentially set by pg_upgrade_support functions */
 Oid                    binary_upgrade_next_heap_pg_class_oid = InvalidOid;
@@ -3070,6 +3071,9 @@ heap_truncate(List *relids)
 {
        List       *relations = NIL;
        ListCell   *cell;
+       instr_time  start;
+       instr_time  duration;
+       INSTR_TIME_SET_CURRENT(start);
 
        /* Open relations for processing, and grab exclusive access on each */
        foreach(cell, relids)
@@ -3095,6 +3099,10 @@ heap_truncate(List *relids)
                /* Close the relation, but keep exclusive lock on it until commit */
                table_close(rel, NoLock);
        }
+
+       INSTR_TIME_SET_CURRENT(duration);
+       INSTR_TIME_SUBTRACT(duration, start);
+       elog(INFO, 'heap_truncate time: %.3f ms\n', INSTR_TIME_GET_MILLISEC(duration));
 }
 
 /*
diff --git a/src/backend/commands/tablecmds.c b/src/backend/commands/tablecmds.c
index 016ae0a65f9..0172ec8bc5e 100644
--- a/src/backend/commands/tablecmds.c
+++ b/src/backend/commands/tablecmds.c
@@ -105,6 +105,8 @@
 #include 'utils/typcache.h'
 #include 'utils/usercontext.h'
 
+#include 'portability/instr_time.h'
+
 /*
  * ON COMMIT action list
  */
@@ -17120,6 +17122,9 @@ PreCommit_on_commit_actions(void)
        ListCell   *l;
        List       *oids_to_truncate = NIL;
        List       *oids_to_drop = NIL;
+       instr_time  start;
+       instr_time  duration;
+       INSTR_TIME_SET_CURRENT(start);
 
        foreach(l, on_commits)
        {
@@ -17211,6 +17216,10 @@ PreCommit_on_commit_actions(void)
                }
 #endif
        }
+
+       INSTR_TIME_SET_CURRENT(duration);
+       INSTR_TIME_SUBTRACT(duration, start);
+       elog(INFO, 'PreCommit_on_commit_actions time: %.3f ms\n', INSTR_TIME_GET_MILLISEC(duration));
 }
 
 /*
```
来自tom lane的评价，因为场景比较单一，对于优化此处要增加代码复杂度，让他并不感兴趣

&lt;img width='664' height='517' alt='Image' src='https://github.com/user-attachments/assets/e05f943c-057d-4d46-882e-2b0fdd31ac72' /&gt;。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/%E6%9F%A5%E8%AF%A2%E8%80%97%E6%97%B6%E5%90%8C%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%9A%84%E6%95%B0%E9%87%8F%E5%91%88%E7%BA%BF%E6%80%A7%E5%A2%9E%E9%95%BF.html</guid><pubDate>Wed, 03 Sep 2025 09:19:04 +0000</pubDate></item><item><title>简单解析下Toast</title><link>https://Z-Xiao-M.github.io/github.io/post/%E7%AE%80%E5%8D%95%E8%A7%A3%E6%9E%90%E4%B8%8BToast.html</link><description># 什么是TOAST

PostgreSQL 的 TOAST（The Oversized-Attribute Storage Technique，超大属性存储技术）是针对大尺寸数据（如长文本、二进制数据等）的存储优化机制，当字段数据超过阈值时，会自动将其压缩或拆分后存储到独立的 TOAST 表中，主表仅保留引用指针，既解决了单条记录存储容量受限问题，又通过透明操作、多种存储策略和独立表设计，平衡了存储效率与访问性能，对 TEXT、BYTEA、JSONB 等可能存储大数据的类型尤为有效。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/%E7%AE%80%E5%8D%95%E8%A7%A3%E6%9E%90%E4%B8%8BToast.html</guid><pubDate>Wed, 03 Sep 2025 05:42:58 +0000</pubDate></item><item><title>CREATE TABLE和文件分支</title><link>https://Z-Xiao-M.github.io/github.io/post/CREATE-TABLE%E5%92%8C%E6%96%87%E4%BB%B6%E5%88%86%E6%94%AF.html</link><description># 文件分支

在 PostgreSQL 中，一个表的所有信息分别存储在几个不同的分支中，每个分支包含特定类型的数据，分支文件的存放路径通常为\$PGDATA/base/\[数据库OID]/xxx，当其大小达到 1GB （默认值，可以编译时修改）时，就会创建该分支的另一个文件 (这些文件有时被称为段)。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/CREATE-TABLE%E5%92%8C%E6%96%87%E4%BB%B6%E5%88%86%E6%94%AF.html</guid><pubDate>Tue, 02 Sep 2025 10:13:12 +0000</pubDate></item><item><title>两表别名一致能做关联查询吗？</title><link>https://Z-Xiao-M.github.io/github.io/post/%E4%B8%A4%E8%A1%A8%E5%88%AB%E5%90%8D%E4%B8%80%E8%87%B4%E8%83%BD%E5%81%9A%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E5%90%97%EF%BC%9F.html</link><description>### 两表别名一致能做关联查询吗
按照正常的理解，一般是不能的，就像PostgreSQL
```sql
postgres=# create table t10(id1 int, name1 varchar(32));
CREATE TABLE
postgres=# create table t11(id2 int, name2 varchar(32));
CREATE TABLE
postgres=# insert into t10 values(1,'test1');
INSERT 0 1
postgres=# insert into t10 values(2,'test2');
INSERT 0 1
postgres=# insert into t11 values(1,'test3');
INSERT 0 1
postgres=# select bc.name2 from t10 bc left join t11 bc on bc.id1 = bc.id2;
ERROR:  table name 'bc' specified more than once
postgres=# 
```
但是Oracle不一样，它还真能执行，执行结果如下

```sql
SQL&gt; create table t10(id1 int, name1 varchar2(32));

Table created.

SQL&gt; create table t11(id2 int, name2 varchar2(32));

Table created.

SQL&gt; insert into t10 values(1,'test1');

1 row created.

SQL&gt; insert into t10 values(2,'test2');

1 row created.

SQL&gt; insert into t11 values(1,'test3');

1 row created.

SQL&gt; EXPLAIN PLAN FOR select bc.name2 from t10 bc left join t11 bc on bc.id1 = bc.id2;

Explained.

SQL&gt; SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------
Plan hash value: 1151093956

---------------------------------------------------------------------------
| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |      |     2 |    88 |     6   (0)| 00:00:01 |
|*  1 |  HASH JOIN OUTER   |      |     2 |    88 |     6   (0)| 00:00:01 |
|   2 |   TABLE ACCESS FULL| T10  |     2 |    26 |     3   (0)| 00:00:01 |
|   3 |   TABLE ACCESS FULL| T11  |     1 |    31 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------


PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------

   1 - access('BC'.'ID1'='BC'.'ID2'(+))

Note
-----
   - dynamic statistics used: dynamic sampling (level=2)

19 rows selected.

SQL&gt; select bc.name2 from t10 bc left join t11 bc on bc.id1 = bc.id2;

NAME2
--------------------------------------------------------------------------------
test3


SQL&gt; 
``` 
想不通oracle为什么要支持这种写法，此处用作记录~

。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/%E4%B8%A4%E8%A1%A8%E5%88%AB%E5%90%8D%E4%B8%80%E8%87%B4%E8%83%BD%E5%81%9A%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E5%90%97%EF%BC%9F.html</guid><pubDate>Mon, 01 Sep 2025 08:11:22 +0000</pubDate></item><item><title>Oracle"特色"——常量/变量充当函数入参默认值</title><link>https://Z-Xiao-M.github.io/github.io/post/Oracle-%E7%89%B9%E8%89%B2-%E2%80%94%E2%80%94%E5%B8%B8%E9%87%8F-%E5%8F%98%E9%87%8F%E5%85%85%E5%BD%93%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%82%E9%BB%98%E8%AE%A4%E5%80%BC.html</link><description>诚如今天的主题所言：'同学，你能接受常量/变量充当函数入参默认值吗？'

在PL/SQL中，函数入参默认值不就是输入参数类型后面的DEFAULT，就好比示例中的256，通常来说都是一个写定了的数据值。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/Oracle-%E7%89%B9%E8%89%B2-%E2%80%94%E2%80%94%E5%B8%B8%E9%87%8F-%E5%8F%98%E9%87%8F%E5%85%85%E5%BD%93%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%82%E9%BB%98%E8%AE%A4%E5%80%BC.html</guid><pubDate>Mon, 01 Sep 2025 07:15:05 +0000</pubDate></item><item><title>Oracle"特色"——自定义带默认值的复合类型</title><link>https://Z-Xiao-M.github.io/github.io/post/Oracle-%E7%89%B9%E8%89%B2-%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%A6%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B.html</link><description>今天的这个主题就很显而易见了，这个我觉得怪怪的想要进行分享的原因是：

**你甚至可以在Oracle数据库内部定义出带默认值的复合类型！！！主要其实也是我玩PG玩多了，没瞅见过自带默认值的复合类型。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/Oracle-%E7%89%B9%E8%89%B2-%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%A6%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B.html</guid><pubDate>Mon, 01 Sep 2025 07:14:11 +0000</pubDate></item><item><title>"颗粒度"没对齐——让人费解的CHAR（1）</title><link>https://Z-Xiao-M.github.io/github.io/post/-%E9%A2%97%E7%B2%92%E5%BA%A6-%E6%B2%A1%E5%AF%B9%E9%BD%90%E2%80%94%E2%80%94%E8%AE%A9%E4%BA%BA%E8%B4%B9%E8%A7%A3%E7%9A%84CHAR%EF%BC%881%EF%BC%89.html</link><description>看到今天的主题，可能有不少的朋友会吐槽一个Oracle的CHAR（1）类型有什么让人费解的这不是简简单单吗？而且CHAR（1）在各个数据库中也都支持的呀？我想说的是大伙，别着急咱们接下来慢慢看。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/-%E9%A2%97%E7%B2%92%E5%BA%A6-%E6%B2%A1%E5%AF%B9%E9%BD%90%E2%80%94%E2%80%94%E8%AE%A9%E4%BA%BA%E8%B4%B9%E8%A7%A3%E7%9A%84CHAR%EF%BC%881%EF%BC%89.html</guid><pubDate>Mon, 01 Sep 2025 07:12:58 +0000</pubDate></item><item><title>羲和（halo）数据库集合类型系列——学会可变数组(Varray)的正确使用</title><link>https://Z-Xiao-M.github.io/github.io/post/%E7%BE%B2%E5%92%8C%EF%BC%88halo%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%AD%A6%E4%BC%9A%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84%28Varray%29%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8.html</link><description>一、前言  

前不久，咱们带来了关于羲和数据库集合类型中的嵌套表、关联数组的使用，因为中途临时有事情要忙，所以小咕了一会，相关链接如下

[羲和（halo）数据库集合类型系列——学会嵌套表(Nested Table)的正确使用](https://www.modb.pro/db/1844644828275109888)  

[羲和（halo）数据库集合类型系列——关联数组（Associative Array）](https://www.modb.pro/db/1845638860305432576)  

今天要给大家带来的是**羲和（halo）数据库集合类型基础用法最终章——****可变数组(Varray)****相关内容。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/%E7%BE%B2%E5%92%8C%EF%BC%88halo%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%AD%A6%E4%BC%9A%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84%28Varray%29%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8.html</guid><pubDate>Mon, 01 Sep 2025 07:10:44 +0000</pubDate></item><item><title>羲和（halo）数据库集合类型系列——关联数组（Associative Array）</title><link>https://Z-Xiao-M.github.io/github.io/post/%E7%BE%B2%E5%92%8C%EF%BC%88halo%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84%EF%BC%88Associative-Array%EF%BC%89.html</link><description>一、前言
====

前不久，咱们带来了关于羲和数据库集合类型中的嵌套表的使用，顺带和Oracle19c对比了一下，基本功能上大差不差，前文链接如下

[羲和（halo）数据库集合类型系列——学会嵌套表(Nested Table)的正确使用](https://www.modb.pro/db/1844644828275109888)  

上次将两款数据库的测试内容和运行结果一起截图，结果贴到文章中反而显得不是很清楚，像我这种眼神不太好使的同学，还需要多点一下图片。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/%E7%BE%B2%E5%92%8C%EF%BC%88halo%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84%EF%BC%88Associative-Array%EF%BC%89.html</guid><pubDate>Mon, 01 Sep 2025 07:09:48 +0000</pubDate></item><item><title>羲和（halo）数据库集合类型系列——学会嵌套表(Nested Table)的正确使用</title><link>https://Z-Xiao-M.github.io/github.io/post/%E7%BE%B2%E5%92%8C%EF%BC%88halo%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%AD%A6%E4%BC%9A%E5%B5%8C%E5%A5%97%E8%A1%A8%28Nested-Table%29%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8.html</link><description>一、集合类型
======

在Oracle数据库中集合类型分为以下三种，分别为关联数组(Associative Array)、嵌套表(Nested Table)和可变数组(VARRAY)。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/%E7%BE%B2%E5%92%8C%EF%BC%88halo%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%AD%A6%E4%BC%9A%E5%B5%8C%E5%A5%97%E8%A1%A8%28Nested-Table%29%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8.html</guid><pubDate>Mon, 01 Sep 2025 07:08:57 +0000</pubDate></item><item><title>如何使用羲和（Halo）数据库的动态SQL语句功能</title><link>https://Z-Xiao-M.github.io/github.io/post/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%BE%B2%E5%92%8C%EF%BC%88Halo%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8A%A8%E6%80%81SQL%E8%AF%AD%E5%8F%A5%E5%8A%9F%E8%83%BD.html</link><description>一、前言
====

SQL语句在**程序编译**期间就已经确定，绝大多数的编译情况属于这种类型，我们称之为静态SQL。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%BE%B2%E5%92%8C%EF%BC%88Halo%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8A%A8%E6%80%81SQL%E8%AF%AD%E5%8F%A5%E5%8A%9F%E8%83%BD.html</guid><pubDate>Mon, 01 Sep 2025 07:08:07 +0000</pubDate></item><item><title>羲和（Halo）数据库RAW类型初体验</title><link>https://Z-Xiao-M.github.io/github.io/post/%E7%BE%B2%E5%92%8C%EF%BC%88Halo%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93RAW%E7%B1%BB%E5%9E%8B%E5%88%9D%E4%BD%93%E9%AA%8C.html</link><description>一、RAW类型回顾
=========

在Oracle数据库中，RAW类型是一种可变长数据类型，一般用于存储二进制数据。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/%E7%BE%B2%E5%92%8C%EF%BC%88Halo%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93RAW%E7%B1%BB%E5%9E%8B%E5%88%9D%E4%BD%93%E9%AA%8C.html</guid><pubDate>Mon, 01 Sep 2025 07:07:24 +0000</pubDate></item><item><title>打破认知幻像：你写的SQL是否如你心意？</title><link>https://Z-Xiao-M.github.io/github.io/post/%E6%89%93%E7%A0%B4%E8%AE%A4%E7%9F%A5%E5%B9%BB%E5%83%8F%EF%BC%9A%E4%BD%A0%E5%86%99%E7%9A%84SQL%E6%98%AF%E5%90%A6%E5%A6%82%E4%BD%A0%E5%BF%83%E6%84%8F%EF%BC%9F.html</link><description>一、前言
====

最近网上冲浪的时候，翻着翻着翻到一篇有趣的文章，估摸着应该是盖老师写的。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/%E6%89%93%E7%A0%B4%E8%AE%A4%E7%9F%A5%E5%B9%BB%E5%83%8F%EF%BC%9A%E4%BD%A0%E5%86%99%E7%9A%84SQL%E6%98%AF%E5%90%A6%E5%A6%82%E4%BD%A0%E5%BF%83%E6%84%8F%EF%BC%9F.html</guid><pubDate>Mon, 01 Sep 2025 06:55:16 +0000</pubDate></item><item><title>Oracle、PostgreSQL、羲和（Halo）数据库中的的IN、OUT 和 INOUT参数模式</title><link>https://Z-Xiao-M.github.io/github.io/post/Oracle%E3%80%81PostgreSQL%E3%80%81%E7%BE%B2%E5%92%8C%EF%BC%88Halo%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E7%9A%84IN%E3%80%81OUT-%E5%92%8C-INOUT%E5%8F%82%E6%95%B0%E6%A8%A1%E5%BC%8F.html</link><description>一、前言
----

前些天看到PostgreSQL分会在微信上的一则翻译分享，标题为Oracle 与 PostgreSQL 中的 IN、OUT 和 INOUT 参数。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/Oracle%E3%80%81PostgreSQL%E3%80%81%E7%BE%B2%E5%92%8C%EF%BC%88Halo%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E7%9A%84IN%E3%80%81OUT-%E5%92%8C-INOUT%E5%8F%82%E6%95%B0%E6%A8%A1%E5%BC%8F.html</guid><pubDate>Mon, 01 Sep 2025 06:53:37 +0000</pubDate></item><item><title>羲和（Halo）数据库——DBMS_RANDOM浅尝</title><link>https://Z-Xiao-M.github.io/github.io/post/%E7%BE%B2%E5%92%8C%EF%BC%88Halo%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94DBMS_RANDOM%E6%B5%85%E5%B0%9D.html</link><description>&lt;html&gt;
&lt;body&gt;
&lt;!--StartFragment--&gt;&lt;p style='padding: 0px; margin: 10px 0px; box-sizing: border-box; font-size: 14px; line-height: 1.5; color: rgb(0, 0, 0); font-family: PingFangSC-Regular, &amp;quot;Microsoft Yahei&amp;quot;; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;'&gt;在ORACLE中DBMS_RANDOM用于生成随机数、随机字符串等。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/%E7%BE%B2%E5%92%8C%EF%BC%88Halo%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94DBMS_RANDOM%E6%B5%85%E5%B0%9D.html</guid><pubDate>Mon, 01 Sep 2025 06:52:44 +0000</pubDate></item><item><title>羲和（Halo）数据库——DBMS_SQL浅尝</title><link>https://Z-Xiao-M.github.io/github.io/post/%E7%BE%B2%E5%92%8C%EF%BC%88Halo%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94DBMS_SQL%E6%B5%85%E5%B0%9D.html</link><description>本文将向大家展示如何在羲和（Halo）数据库中使用DBMS\_SQL，本文测试案例除部分表结构和部分测试数据之外，其余均来自ORACLE官方测试文档，所有测试案例放置文章末尾以供学习使用。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/%E7%BE%B2%E5%92%8C%EF%BC%88Halo%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94DBMS_SQL%E6%B5%85%E5%B0%9D.html</guid><pubDate>Mon, 01 Sep 2025 06:47:36 +0000</pubDate></item><item><title>聊聊pg_bulkload的大概的实现逻辑</title><link>https://Z-Xiao-M.github.io/github.io/post/%E8%81%8A%E8%81%8Apg_bulkload%E7%9A%84%E5%A4%A7%E6%A6%82%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91.html</link><description>&gt; 好好好，好久不见，最近偶然了解到了pg\_bulkload这一插件，然后花了点时间看了看它是如何实现的，又想到好久没有写东西了，咕了太久，有点怪不好意思的，所以决定写点东西，摆脱鸽子🕊的嫌疑。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/%E8%81%8A%E8%81%8Apg_bulkload%E7%9A%84%E5%A4%A7%E6%A6%82%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91.html</guid><pubDate>Mon, 01 Sep 2025 06:32:59 +0000</pubDate></item><item><title>没有from是否能够执行count操作</title><link>https://Z-Xiao-M.github.io/github.io/post/%E6%B2%A1%E6%9C%89from%E6%98%AF%E5%90%A6%E8%83%BD%E5%A4%9F%E6%89%A7%E8%A1%8Ccount%E6%93%8D%E4%BD%9C.html</link><description>一、场景构建
======

这是一个非常简单的场景，这里存在一张表，表名t，往其中随便插入三行数据，然后执行查询语句：`select count(*) from t;`

    create table t(id integer);
    insert into t values(1),(2),(3);
    select count(*) from t;

执行结果

    postgres=# create table t(id integer);
    CREATE TABLE
    postgres=# insert into t values(1),(2),(3);
    INSERT 0 3
    postgres=# select count(*) from t;
     count 
    -------
         3
    (1 row)

可以看到执行count结果为3，这在正常不过了。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/%E6%B2%A1%E6%9C%89from%E6%98%AF%E5%90%A6%E8%83%BD%E5%A4%9F%E6%89%A7%E8%A1%8Ccount%E6%93%8D%E4%BD%9C.html</guid><pubDate>Mon, 01 Sep 2025 06:30:27 +0000</pubDate></item><item><title>外国CTO也感兴趣的开源数据库项目——openHalo</title><link>https://Z-Xiao-M.github.io/github.io/post/%E5%A4%96%E5%9B%BDCTO%E4%B9%9F%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94openHalo.html</link><description>一、openHalo
==========

大概三个礼拜前，也就是四月一（愚人节）的时候，我们将羲和（Halo）数据库关于MySQL兼容能力这一块，独立做成了一个项目，并且在github上开源了出去。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/%E5%A4%96%E5%9B%BDCTO%E4%B9%9F%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94openHalo.html</guid><pubDate>Mon, 01 Sep 2025 06:29:44 +0000</pubDate></item><item><title>PostgreSQL——关于autocommit功能的实现</title><link>https://Z-Xiao-M.github.io/github.io/post/PostgreSQL%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8Eautocommit%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0.html</link><description>一、前言
====

文章标题为PostgreSQL——关于autocommit功能的实现，其实更为准确来说应该是psql——关于autocommit功能的实现，因为这个参数其实属于psql。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/PostgreSQL%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8Eautocommit%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0.html</guid><pubDate>Mon, 01 Sep 2025 06:27:09 +0000</pubDate></item><item><title>玩一玩系列——玩玩pg_dirtyread</title><link>https://Z-Xiao-M.github.io/github.io/post/%E7%8E%A9%E4%B8%80%E7%8E%A9%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%8E%A9%E7%8E%A9pg_dirtyread.html</link><description>一、前言
====

很早其实就知道有这么一个插件存在，叫做pg\_dirtyread，就是一直没去上手玩玩，趁着有空，写点东西。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/%E7%8E%A9%E4%B8%80%E7%8E%A9%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%8E%A9%E7%8E%A9pg_dirtyread.html</guid><pubDate>Mon, 01 Sep 2025 06:26:19 +0000</pubDate></item><item><title>看懂PostgreSQL where子句中条件的先后执行顺序</title><link>https://Z-Xiao-M.github.io/github.io/post/%E7%9C%8B%E6%87%82PostgreSQL-where%E5%AD%90%E5%8F%A5%E4%B8%AD%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%85%88%E5%90%8E%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.html</link><description>一、前言
====

前几天有个同事问了我一个问题，问题简化之后，大概如下面描述：在PostgreSQL中，存在一张表ta，表中数据存在两个值，分别是零和一。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/%E7%9C%8B%E6%87%82PostgreSQL-where%E5%AD%90%E5%8F%A5%E4%B8%AD%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%85%88%E5%90%8E%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.html</guid><pubDate>Mon, 01 Sep 2025 06:25:25 +0000</pubDate></item><item><title>玩一玩系列——玩玩postgres_fdw</title><link>https://Z-Xiao-M.github.io/github.io/post/%E7%8E%A9%E4%B8%80%E7%8E%A9%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%8E%A9%E7%8E%A9postgres_fdw.html</link><description>一、前言
====

本文仅记录和分享一下关于PostgreSQL的FDW（外部数据包装器）的简单介绍和使用，此次不包含源码分析。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/%E7%8E%A9%E4%B8%80%E7%8E%A9%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%8E%A9%E7%8E%A9postgres_fdw.html</guid><pubDate>Mon, 01 Sep 2025 06:21:16 +0000</pubDate></item><item><title>玩一玩系列——玩玩login_hook</title><link>https://Z-Xiao-M.github.io/github.io/post/%E7%8E%A9%E4%B8%80%E7%8E%A9%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%8E%A9%E7%8E%A9login_hook.html</link><description>一、PostgreSQL登录事件触发器
===================

在PostgreSQL17版本引入了登录事件触发器，可以用于登录之后记录一些信息或者完成一些初始化动作。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/%E7%8E%A9%E4%B8%80%E7%8E%A9%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%8E%A9%E7%8E%A9login_hook.html</guid><pubDate>Mon, 01 Sep 2025 06:20:15 +0000</pubDate></item><item><title>明明想执行的SQL是DELETE、UPDATE，但为什么看到的是SELECT（FDW的实现原理解析）</title><link>https://Z-Xiao-M.github.io/github.io/post/%E6%98%8E%E6%98%8E%E6%83%B3%E6%89%A7%E8%A1%8C%E7%9A%84SQL%E6%98%AFDELETE%E3%80%81UPDATE%EF%BC%8C%E4%BD%86%E4%B8%BA%E4%BB%80%E4%B9%88%E7%9C%8B%E5%88%B0%E7%9A%84%E6%98%AFSELECT%EF%BC%88FDW%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%EF%BC%89.html</link><description>一、场景复现
======

开门见山，一个关于oracle\_fdw的简单场景如下：

    halo0root=# \d+ emp
                                                   Foreign table 'public.emp'
     Column |         Type          | Collation | Nullable | Default | FDW options  | Storage  | Stats target | Description 
    --------+-----------------------+-----------+----------+---------+--------------+----------+--------------+-------------
     name   | character varying(20) |           | not null |         | (key 'true') | extended |              | 
     age    | numeric               |           |          |         |              | main     |              | 
    Server: oradb
    FDW options: (schema 'ZM', 'table' 'EMP')
    
    halo0root=# \des+
                                                          List of foreign servers
     Name  | Owner | Foreign-data wrapper | Access privileges | Type | Version |               FDW options                | Description 
    -------+-------+----------------------+-------------------+------+---------+------------------------------------------+-------------
     oradb | halo  | oracle_fdw           |                   |      |         | (dbserver '//10.16.6.188:1521/orclpdb1') | 
    (1 row)
    
    halo0root=# EXPLAIN VERBOSE DELETE FROM emp WHERE age = 25;
                                                            QUERY PLAN                                                         
    ---------------------------------------------------------------------------------------------------------------------------
     Delete on public.emp  (cost=10000.00..20000.00 rows=0 width=0)
       Oracle statement: DELETE FROM 'ZM'.'EMP' WHERE 'NAME' = :k1
       -&gt;  Foreign Scan on public.emp  (cost=10000.00..20000.00 rows=1000 width=58)
             Output: name
             Oracle query: SELECT /*9ad36f25074bd711*/ r1.'NAME', r1.'AGE' FROM 'ZM'.'EMP' r1 WHERE (r1.'AGE' = 25) FOR UPDATE
             Oracle plan: SELECT STATEMENT
             Oracle plan:   FOR UPDATE
             Oracle plan:     BUFFER SORT
             Oracle plan:       TABLE ACCESS FULL EMP  (filter 'R1'.'AGE'=25)
     Query Identifier: -1174117518881599247
    (10 rows)

这里可以很明显的看到，虽然我们敲得是EXPLAIN VERBOSE DELETE ...，但是实际的Oracle query却是SELECT，同时UPDATE也是如此

    halo0root=# EXPLAIN VERBOSE UPDATE emp SET name = 'zzz' WHERE age = 25;
                                                            QUERY PLAN                                                         
    ---------------------------------------------------------------------------------------------------------------------------
     Update on public.emp  (cost=10000.00..20000.00 rows=0 width=0)
       Oracle statement: UPDATE 'ZM'.'EMP' SET 'NAME' = :p1 WHERE 'NAME' = :k1
       -&gt;  Foreign Scan on public.emp  (cost=10000.00..20000.00 rows=1000 width=230)
             Output: 'zzz'::character varying(20), name, emp.*
             Oracle query: SELECT /*9ad36f25074bd711*/ r1.'NAME', r1.'AGE' FROM 'ZM'.'EMP' r1 WHERE (r1.'AGE' = 25) FOR UPDATE
             Oracle plan: SELECT STATEMENT
             Oracle plan:   FOR UPDATE
             Oracle plan:     BUFFER SORT
             Oracle plan:       TABLE ACCESS FULL EMP  (filter 'R1'.'AGE'=25)
     Query Identifier: -2711433616002583057
    (10 rows)

那么问题就如文章标题所述了，这是为什么呢？

  

二、原理分析
======

原因其实也很简单，因为对于PostgreSQL而言，外部表是一种很特殊的存在，它仅仅只是一个远端表的映射，实际的数据依旧还是存储在远端，

当我们在本地的PostgreSQL访问外部表的时候，实际上就是将当前的查询语句，下发至远端数据库，再将查询到的数据传回本地的PostgreSQL中参与实际的计算之类的。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/%E6%98%8E%E6%98%8E%E6%83%B3%E6%89%A7%E8%A1%8C%E7%9A%84SQL%E6%98%AFDELETE%E3%80%81UPDATE%EF%BC%8C%E4%BD%86%E4%B8%BA%E4%BB%80%E4%B9%88%E7%9C%8B%E5%88%B0%E7%9A%84%E6%98%AFSELECT%EF%BC%88FDW%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%EF%BC%89.html</guid><pubDate>Mon, 01 Sep 2025 06:19:02 +0000</pubDate></item><item><title>在PostgreSQL中，你不仅可以看到Bad Apple，还可以看故人唱跳、rap、打篮球</title><link>https://Z-Xiao-M.github.io/github.io/post/%E5%9C%A8PostgreSQL%E4%B8%AD%EF%BC%8C%E4%BD%A0%E4%B8%8D%E4%BB%85%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0Bad-Apple%EF%BC%8C%E8%BF%98%E5%8F%AF%E4%BB%A5%E7%9C%8B%E6%95%85%E4%BA%BA%E5%94%B1%E8%B7%B3%E3%80%81rap%E3%80%81%E6%89%93%E7%AF%AE%E7%90%83.html</link><description>一、前言
====

也是在前不久，我翻到了一个“有趣”的项目，如标题所言，这个PostgreSQL插件项目就是可能做到在psql客户端播放Bad Apple，和鸽鸽的唱跳、rap、打篮球的名场面。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/%E5%9C%A8PostgreSQL%E4%B8%AD%EF%BC%8C%E4%BD%A0%E4%B8%8D%E4%BB%85%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0Bad-Apple%EF%BC%8C%E8%BF%98%E5%8F%AF%E4%BB%A5%E7%9C%8B%E6%95%85%E4%BA%BA%E5%94%B1%E8%B7%B3%E3%80%81rap%E3%80%81%E6%89%93%E7%AF%AE%E7%90%83.html</guid><pubDate>Mon, 01 Sep 2025 06:18:11 +0000</pubDate></item><item><title>简单聊聊PostgreSQL中的多态伪类型</title><link>https://Z-Xiao-M.github.io/github.io/post/%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8APostgreSQL%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81%E4%BC%AA%E7%B1%BB%E5%9E%8B.html</link><description>一、前言
====

也是好久没有写文章了，主要是前阵子比较忙，还有外加上喜欢骑车出去兜风，以至于一而再，再而三的咕咕。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8APostgreSQL%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81%E4%BC%AA%E7%B1%BB%E5%9E%8B.html</guid><pubDate>Sun, 31 Aug 2025 08:18:02 +0000</pubDate></item><item><title>搭建一个多主复制数据回环场景</title><link>https://Z-Xiao-M.github.io/github.io/post/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%A4%9A%E4%B8%BB%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE%E5%9B%9E%E7%8E%AF%E5%9C%BA%E6%99%AF.html</link><description>一、前言
====

最近也是看着看着，看到了逻辑复制这块，事实上我很少接触过这块，所以就当练练手了。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%A4%9A%E4%B8%BB%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE%E5%9B%9E%E7%8E%AF%E5%9C%BA%E6%99%AF.html</guid><pubDate>Sun, 31 Aug 2025 08:03:25 +0000</pubDate></item><item><title>PostgreSQL——关于临时表的二三事</title><link>https://Z-Xiao-M.github.io/github.io/post/PostgreSQL%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8E%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B.html</link><description># 一、前言

说起临时表，多数的DBA同学们第一时间都会想到Oracle的全局临时表，而对于PG而言，虽然存在对应的全局临时表语法，但是并没有实质的全局临时表功能。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/post/PostgreSQL%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8E%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B.html</guid><pubDate>Sun, 31 Aug 2025 04:06:59 +0000</pubDate></item><item><title>关于</title><link>https://Z-Xiao-M.github.io/github.io/about.html</link><description>不知道写点什么，脑袋空空，
突然觉得自己也并没有多了解我自己。</description><guid isPermaLink="true">https://Z-Xiao-M.github.io/github.io/about.html</guid><pubDate>Sun, 31 Aug 2025 07:27:51 +0000</pubDate></item></channel></rss>