<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    <script src='https://blog.meekdai.com/Gmeek/plugins/GmeekVercount.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><style>body[data-ui-pending] #content {opacity:0;transition:opacity 0.3s ease;}</style><script>document.documentElement.setAttribute('data-ui-pending','true');</script><link rel='stylesheet' href='https://code.buxiantang.top/assets/GmeekBaseTheme.css'><script src='https://code.buxiantang.top/assets/GmeekCustomizeCss.js' defer></script>
    <link rel="icon" href="https://z-xiao-m.github.io/github.io/avatar.svg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="# 文件分支

在 PostgreSQL 中，一个表的所有信息分别存储在几个不同的分支中，每个分支包含特定类型的数据，分支文件的存放路径通常为\$PGDATA/base/\[数据库OID]/xxx，当其大小达到 1GB （默认值，可以编译时修改）时，就会创建该分支的另一个文件 (这些文件有时被称为段)。">
<meta property="og:title" content="CREATE TABLE和文件分支">
<meta property="og:description" content="# 文件分支

在 PostgreSQL 中，一个表的所有信息分别存储在几个不同的分支中，每个分支包含特定类型的数据，分支文件的存放路径通常为\$PGDATA/base/\[数据库OID]/xxx，当其大小达到 1GB （默认值，可以编译时修改）时，就会创建该分支的另一个文件 (这些文件有时被称为段)。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://Z-Xiao-M.github.io/github.io/post/CREATE%20TABLE-he-wen-jian-fen-zhi.html">
<meta property="og:image" content="https://z-xiao-m.github.io/github.io/avatar.svg">
<title>CREATE TABLE和文件分支</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>
<style>#postBody{font-size:20px}</style>



<body>
    <div id="header">
<h1 class="postTitle">CREATE TABLE和文件分支</h1>
<div class="title-right">
    <a href="https://Z-Xiao-M.github.io/github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/Z-Xiao-M/github.io/issues/28" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h1>文件分支</h1>
<p>在 PostgreSQL 中，一个表的所有信息分别存储在几个不同的分支中，每个分支包含特定类型的数据，分支文件的存放路径通常为$PGDATA/base/[数据库OID]/xxx，当其大小达到 1GB （默认值，可以编译时修改）时，就会创建该分支的另一个文件 (这些文件有时被称为段)。段的序列号会被添加到文件名的末尾。</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-k">typedef</span> <span class="pl-k">enum</span> <span class="pl-smi">ForkNumber</span>
{
	<span class="pl-s1">InvalidForkNumber</span> <span class="pl-c1">=</span> <span class="pl-c1">-1</span>,
	<span class="pl-c1">MAIN_FORKNUM</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>,
	<span class="pl-c1">FSM_FORKNUM</span>,
	<span class="pl-c1">VISIBILITYMAP_FORKNUM</span>,
	<span class="pl-c1">INIT_FORKNUM</span>
} <span class="pl-smi">ForkNumber</span>;</pre></div>
<ul>
<li><strong>主文件（主分支）</strong> 是存储表实际数据的文件，以表的<code class="notranslate">relfilenode</code>命名（通常来说和表的oid保持一致，但也有不一致的情形，比如说使用了 <code class="notranslate">TRUNCATE</code>、<code class="notranslate">REINDEX、CLUSTER</code> 等等）。</li>
<li><strong>空闲空间映射</strong> 用于跟踪页内的可用空间。其容量一直在变化，vacuum 后变大，并在新的行版本出现时变小。空闲空间映射用于快速找到可以容纳被插入的新数据的页面。所有与空闲空间映射相关的文件都带有 _fsm 后缀。为了加快搜索速度，空闲空间映射以一棵树的形式组织，它至少有三个数据页 (因此即使是几乎空的表，其文件大小也会有所体现)。</li>
<li><strong>可见性映射</strong> 可以快速显示页面是否需要被清理或冻结。 它为每个表页面提供了两个比特位。第一个比特，为仅包含最新行版本的页面设置。vacuum 操作会跳过这样的页面，因为没有东西需要清理。此外，当某个事务尝试从这样的页面读取一行数据时，没有必要检查其可见性，因此便可以使用仅索引扫描。当页面包含的行版本都已被冻结后，便会设置第二个比特。可见性映射文件带有 _vm 后缀。它们通常是最小的文件</li>
<li><strong>初始分支</strong> 仅适用于UNLOGGED TABLE及其索引。此类对象与常规对象相同，不同之处在于对它们执行的任何操作都不会写入预写式日志。这使得这些操作的速度非常的快，但如果发生故障，将无法恢复一致的数据。因此，在恢复期间，PostgreSQL 会简单地删除此类对象的所有分支，并用初始分支覆盖主分支，从而创建了一个伪文件。</li>
</ul>
<blockquote>
<p>更多详细内容请参考 <a href="https://postgres-internals.cn/docs/chapter01/" rel="nofollow">第 1 章：介绍 – PostgreSQL 14 Internals</a></p>
</blockquote>
<h1>UNLOGGED TABLE</h1>
<p>通过上面的表述，我们了解到对于postgresql而言，存在四种文件分支，而UNLOGGED TABLE是唯一一个同时拥有四种分支的表。接下来让我们简单瞅瞅并验证一下上面的内容。</p>
<div class="highlight highlight-source-sql"><pre class="notranslate">psql (<span class="pl-c1">16</span>.<span class="pl-c1">10</span>)
Type <span class="pl-s"><span class="pl-pds">"</span>help<span class="pl-pds">"</span></span> for help.

postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> -- 创建测试表</span>
postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> CREATE UNLOGGED TABLE test_unlogged_table(a int);</span>
CREATE TABLE
postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> -- 查看测试表信息 获取relfilenode</span>
postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> SELECT * FROM PG_CLASS WHERE relname = 'test_unlogged_table' \gx</span>
<span class="pl-k">-</span>[ RECORD <span class="pl-c1">1</span> ]<span class="pl-c"><span class="pl-c">--</span>-----+--------------------</span>
<span class="pl-k">oid</span>                 | <span class="pl-c1">157241</span>
relname             | test_unlogged_table
relnamespace        | <span class="pl-c1">2200</span>
reltype             | <span class="pl-c1">157243</span>
reloftype           | <span class="pl-c1">0</span>
relowner            | <span class="pl-c1">10</span>
relam               | <span class="pl-c1">2</span>
relfilenode         | <span class="pl-c1">157241</span>
reltablespace       | <span class="pl-c1">0</span>
relpages            | <span class="pl-c1">0</span>
reltuples           | <span class="pl-k">-</span><span class="pl-c1">1</span>
relallvisible       | <span class="pl-c1">0</span>
reltoastrelid       | <span class="pl-c1">0</span>
relhasindex         | f
relisshared         | f
relpersistence      | u
relkind             | r
relnatts            | <span class="pl-c1">1</span>
relchecks           | <span class="pl-c1">0</span>
relhasrules         | f
relhastriggers      | f
relhassubclass      | f
relrowsecurity      | f
relforcerowsecurity | f
relispopulated      | t
relreplident        | d
relispartition      | f
relrewrite          | <span class="pl-c1">0</span>
relfrozenxid        | <span class="pl-c1">7288</span>
relminmxid          | <span class="pl-c1">1</span>
relacl              | 
reloptions          | 
relpartbound        | 

postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> -- 查看当前数据库信息 获取对应的oid</span>
postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> SELECT * FROM PG_DATABASE WHERE datname = current_database() \gx</span>
<span class="pl-k">-</span>[ RECORD <span class="pl-c1">1</span> ]<span class="pl-c"><span class="pl-c">--</span>+-------------------------------------</span>
<span class="pl-k">oid</span>            | <span class="pl-c1">5</span>
datname        | postgres
datdba         | <span class="pl-c1">10</span>
encoding       | <span class="pl-c1">6</span>
datlocprovider | c
datistemplate  | f
datallowconn   | t
datconnlimit   | <span class="pl-k">-</span><span class="pl-c1">1</span>
datfrozenxid   | <span class="pl-c1">722</span>
datminmxid     | <span class="pl-c1">1</span>
dattablespace  | <span class="pl-c1">1663</span>
datcollate     | <span class="pl-c1">zh_CN</span>.<span class="pl-c1">UTF</span><span class="pl-k">-</span><span class="pl-c1">8</span>
datctype       | <span class="pl-c1">zh_CN</span>.<span class="pl-c1">UTF</span><span class="pl-k">-</span><span class="pl-c1">8</span>
daticulocale   | 
daticurules    | 
datcollversion | <span class="pl-c1">2</span>.<span class="pl-c1">39</span>
datacl         | {<span class="pl-k">=</span>Tc<span class="pl-k">/</span>postgres,postgres<span class="pl-k">=</span>CTc<span class="pl-k">/</span>postgres}

postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> \! ls $PGDATA/base/5/157241* -al</span>
<span class="pl-k">-</span>rw<span class="pl-c"><span class="pl-c">--</span>----- 1 postgres postgres 0  9月  2 15:43 /data/16/base/5/157241</span>
<span class="pl-k">-</span>rw<span class="pl-c"><span class="pl-c">--</span>----- 1 postgres postgres 0  9月  2 15:43 /data/16/base/5/157241_init</span>
postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> -- 插入一行数据</span>
postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> INSERT INTO test_unlogged_table values(1);</span>
INSERT <span class="pl-c1">0</span> <span class="pl-c1">1</span>
postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> -- VACUUM</span>
postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> VACUUM test_unlogged_table;</span>
VACUUM
postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> -- 查看所有分支文件</span>
postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> \! ls $PGDATA/base/5/157241* -al</span>
<span class="pl-k">-</span>rw<span class="pl-c"><span class="pl-c">--</span>----- 1 postgres postgres  8192  9月  2 15:44 /data/16/base/5/157241</span>
<span class="pl-k">-</span>rw<span class="pl-c"><span class="pl-c">--</span>----- 1 postgres postgres 24576  9月  2 15:44 /data/16/base/5/157241_fsm</span>
<span class="pl-k">-</span>rw<span class="pl-c"><span class="pl-c">--</span>----- 1 postgres postgres     0  9月  2 15:43 /data/16/base/5/157241_init</span>
<span class="pl-k">-</span>rw<span class="pl-c"><span class="pl-c">--</span>----- 1 postgres postgres  8192  9月  2 15:44 /data/16/base/5/157241_vm</span>
postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> </span></pre></div>
<h1>瞅瞅CREATA TABLE代码逻辑</h1>
<p>词法语法略过，只简单介绍部分重要的函数或代码片段</p>
<h2>获取relfilenode和表的oid</h2>
<p>获取relfilenode和表的oid，调用堆栈就不展示了，对应的函数GetNewRelFileNumber具体逻辑如下：</p>
<div class="highlight highlight-source-sql"><pre class="notranslate">RelFileNumber
GetNewRelFileNumber(<span class="pl-k">Oid</span> reltablespace, Relation pg_class, <span class="pl-k">char</span> relpersistence)
{
	RelFileLocatorBackend rlocator;
	<span class="pl-k">char</span>	   <span class="pl-k">*</span>rpath;
	bool		collides;
	BackendId	backend;

	<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">	 * If we ever get here during pg_upgrade, there's something wrong; all</span>
<span class="pl-c">	 * relfilenumber assignments during a binary-upgrade run should be</span>
<span class="pl-c">	 * determined by commands in the dump script.</span>
<span class="pl-c">	 <span class="pl-c">*/</span></span>
	Assert(!IsBinaryUpgrade);

	switch (relpersistence)
	{
		case RELPERSISTENCE_TEMP:
			backend <span class="pl-k">=</span> BackendIdForTempRelations();
			break;
		case RELPERSISTENCE_UNLOGGED:
		case RELPERSISTENCE_PERMANENT:
			backend <span class="pl-k">=</span> InvalidBackendId;
			break;
		default:
			elog(ERROR, <span class="pl-s"><span class="pl-pds">"</span>invalid relpersistence: %c<span class="pl-pds">"</span></span>, relpersistence);
			return InvalidRelFileNumber;	<span class="pl-c"><span class="pl-c">/*</span> placate compiler <span class="pl-c">*/</span></span>
	}

	<span class="pl-c"><span class="pl-c">/*</span> This logic should match RelationInitPhysicalAddr <span class="pl-c">*/</span></span>
	<span class="pl-c1">rlocator</span>.<span class="pl-c1">locator</span>.spcOid <span class="pl-k">=</span> reltablespace ? reltablespace : MyDatabaseTableSpace;
	<span class="pl-c1">rlocator</span>.<span class="pl-c1">locator</span>.dbOid <span class="pl-k">=</span>
		(<span class="pl-c1">rlocator</span>.<span class="pl-c1">locator</span>.spcOid <span class="pl-k">==</span> GLOBALTABLESPACE_OID) ?
		InvalidOid : MyDatabaseId;

	<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">	 * The relpath will vary based on the backend ID, so we must initialize</span>
<span class="pl-c">	 * that properly here to make sure that any collisions based on filename</span>
<span class="pl-c">	 * are properly detected.</span>
<span class="pl-c">	 <span class="pl-c">*/</span></span>
	<span class="pl-c1">rlocator</span>.<span class="pl-c1">backend</span> <span class="pl-k">=</span> backend;

	do
	{
		CHECK_FOR_INTERRUPTS();

		<span class="pl-c"><span class="pl-c">/*</span> Generate the OID <span class="pl-c">*/</span></span>
		if (pg_class)
			<span class="pl-c1">rlocator</span>.<span class="pl-c1">locator</span>.relNumber <span class="pl-k">=</span> GetNewOidWithIndex(pg_class, ClassOidIndexId,
															Anum_pg_class_oid);
		else
			<span class="pl-c1">rlocator</span>.<span class="pl-c1">locator</span>.relNumber <span class="pl-k">=</span> GetNewObjectId();

		<span class="pl-c"><span class="pl-c">/*</span> Check for existing file of same name <span class="pl-c">*/</span></span>
		rpath <span class="pl-k">=</span> relpath(rlocator, MAIN_FORKNUM);

		if (access(rpath, F_OK) <span class="pl-k">==</span> <span class="pl-c1">0</span>)
		{
			<span class="pl-c"><span class="pl-c">/*</span> definite collision <span class="pl-c">*/</span></span>
			collides <span class="pl-k">=</span> true;
		}
		else
		{
			<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">			 * Here we have a little bit of a dilemma: if errno is something</span>
<span class="pl-c">			 * other than ENOENT, should we declare a collision and loop? In</span>
<span class="pl-c">			 * practice it seems best to go ahead regardless of the errno.  If</span>
<span class="pl-c">			 * there is a colliding file we will get an smgr failure when we</span>
<span class="pl-c">			 * attempt to create the new relation file.</span>
<span class="pl-c">			 <span class="pl-c">*/</span></span>
			collides <span class="pl-k">=</span> false;
		}

		pfree(rpath);
	} while (collides);

	return <span class="pl-c1">rlocator</span>.<span class="pl-c1">locator</span>.relNumber;
}</pre></div>
<p>按照生成的oid，生成相对的文件路径并检查对应的文件是否存在</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/user-attachments/assets/bf01c9dd-ba8c-4464-9c30-4223d4c0a8a2"><img width="980" height="197" alt="Image" src="https://github.com/user-attachments/assets/bf01c9dd-ba8c-4464-9c30-4223d4c0a8a2" style="max-width: 100%; height: auto; max-height: 197px;"></a></p>
<h2>分支文件创建</h2>
<p>分支文件创建对应的函数heapam_relation_set_new_filelocator逻辑如下：</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-k">static</span> <span class="pl-smi">void</span>
<span class="pl-en">heapam_relation_set_new_filelocator</span>(<span class="pl-smi">Relation</span> <span class="pl-s1">rel</span>,
									<span class="pl-k">const</span> <span class="pl-smi">RelFileLocator</span> <span class="pl-c1">*</span><span class="pl-s1">newrlocator</span>,
									<span class="pl-smi">char</span> <span class="pl-s1">persistence</span>,
									<span class="pl-smi">TransactionId</span> <span class="pl-c1">*</span><span class="pl-s1">freezeXid</span>,
									<span class="pl-smi">MultiXactId</span> <span class="pl-c1">*</span><span class="pl-s1">minmulti</span>)
{
	<span class="pl-smi">SMgrRelation</span> <span class="pl-s1">srel</span>;

	<span class="pl-c">/*</span>
<span class="pl-c">	 * Initialize to the minimum XID that could put tuples in the table. We</span>
<span class="pl-c">	 * know that no xacts older than RecentXmin are still running, so that</span>
<span class="pl-c">	 * will do.</span>
<span class="pl-c">	 */</span>
	<span class="pl-c1">*</span><span class="pl-s1">freezeXid</span> <span class="pl-c1">=</span> <span class="pl-s1">RecentXmin</span>;

	<span class="pl-c">/*</span>
<span class="pl-c">	 * Similarly, initialize the minimum Multixact to the first value that</span>
<span class="pl-c">	 * could possibly be stored in tuples in the table.  Running transactions</span>
<span class="pl-c">	 * could reuse values from their local cache, so we are careful to</span>
<span class="pl-c">	 * consider all currently running multis.</span>
<span class="pl-c">	 *</span>
<span class="pl-c">	 * XXX this could be refined further, but is it worth the hassle?</span>
<span class="pl-c">	 */</span>
	<span class="pl-c1">*</span><span class="pl-s1">minmulti</span> <span class="pl-c1">=</span> <span class="pl-en">GetOldestMultiXactId</span>();
    <span class="pl-c">// 会在此函数内部创建主分支</span>
	<span class="pl-s1">srel</span> <span class="pl-c1">=</span> <span class="pl-en">RelationCreateStorage</span>(<span class="pl-c1">*</span><span class="pl-s1">newrlocator</span>, <span class="pl-s1">persistence</span>, true);

	<span class="pl-c">/*</span>
<span class="pl-c">	 * If required, set up an init fork for an unlogged table so that it can</span>
<span class="pl-c">	 * be correctly reinitialized on restart.  An immediate sync is required</span>
<span class="pl-c">	 * even if the page has been logged, because the write did not go through</span>
<span class="pl-c">	 * shared_buffers and therefore a concurrent checkpoint may have moved the</span>
<span class="pl-c">	 * redo pointer past our xlog record.  Recovery may as well remove it</span>
<span class="pl-c">	 * while replaying, for example, XLOG_DBASE_CREATE* or XLOG_TBLSPC_CREATE</span>
<span class="pl-c">	 * record. Therefore, logging is necessary even if wal_level=minimal.</span>
<span class="pl-c">	 */</span>
	<span class="pl-k">if</span> (<span class="pl-s1">persistence</span> <span class="pl-c1">==</span> <span class="pl-c1">RELPERSISTENCE_UNLOGGED</span>)
	{
		<span class="pl-en">Assert</span>(<span class="pl-s1">rel</span><span class="pl-c1">-&gt;</span><span class="pl-c1">rd_rel</span><span class="pl-c1">-&gt;</span><span class="pl-c1">relkind</span> <span class="pl-c1">==</span> <span class="pl-c1">RELKIND_RELATION</span> <span class="pl-c1">||</span>
			   <span class="pl-s1">rel</span><span class="pl-c1">-&gt;</span><span class="pl-c1">rd_rel</span><span class="pl-c1">-&gt;</span><span class="pl-c1">relkind</span> <span class="pl-c1">==</span> <span class="pl-c1">RELKIND_MATVIEW</span> <span class="pl-c1">||</span>
			   <span class="pl-s1">rel</span><span class="pl-c1">-&gt;</span><span class="pl-c1">rd_rel</span><span class="pl-c1">-&gt;</span><span class="pl-c1">relkind</span> <span class="pl-c1">==</span> <span class="pl-c1">RELKIND_TOASTVALUE</span>);
		<span class="pl-c">// 为UNLOGGED TABLE创建初始化分支</span>
		<span class="pl-en">smgrcreate</span>(<span class="pl-s1">srel</span>, <span class="pl-c1">INIT_FORKNUM</span>, false);
		<span class="pl-en">log_smgrcreate</span>(<span class="pl-s1">newrlocator</span>, <span class="pl-c1">INIT_FORKNUM</span>);
		<span class="pl-en">smgrimmedsync</span>(<span class="pl-s1">srel</span>, <span class="pl-c1">INIT_FORKNUM</span>);
	}

	<span class="pl-en">smgrclose</span>(<span class="pl-s1">srel</span>);
}</pre></div>
<p>RelationCreateStorage的函数逻辑如下：</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">SMgrRelation</span>
<span class="pl-en">RelationCreateStorage</span>(<span class="pl-smi">RelFileLocator</span> <span class="pl-s1">rlocator</span>, <span class="pl-smi">char</span> <span class="pl-s1">relpersistence</span>,
					  <span class="pl-smi">bool</span> <span class="pl-s1">register_delete</span>)
{
	<span class="pl-smi">SMgrRelation</span> <span class="pl-s1">srel</span>;
	<span class="pl-smi">BackendId</span>	<span class="pl-s1">backend</span>;
	<span class="pl-smi">bool</span>		<span class="pl-s1">needs_wal</span>;

	<span class="pl-en">Assert</span>(!<span class="pl-en">IsInParallelMode</span>());	<span class="pl-c">/* couldn't update pendingSyncHash */</span>

	<span class="pl-k">switch</span> (<span class="pl-s1">relpersistence</span>)
	{
		<span class="pl-k">case</span> <span class="pl-c1">RELPERSISTENCE_TEMP</span>:
			<span class="pl-s1">backend</span> <span class="pl-c1">=</span> <span class="pl-en">BackendIdForTempRelations</span>();
			<span class="pl-s1">needs_wal</span> <span class="pl-c1">=</span> false;
			<span class="pl-k">break</span>;
		<span class="pl-k">case</span> <span class="pl-c1">RELPERSISTENCE_UNLOGGED</span>:
			<span class="pl-s1">backend</span> <span class="pl-c1">=</span> <span class="pl-s1">InvalidBackendId</span>;
			<span class="pl-s1">needs_wal</span> <span class="pl-c1">=</span> false;
			<span class="pl-k">break</span>;
		<span class="pl-k">case</span> <span class="pl-c1">RELPERSISTENCE_PERMANENT</span>:
			<span class="pl-s1">backend</span> <span class="pl-c1">=</span> <span class="pl-s1">InvalidBackendId</span>;
			<span class="pl-s1">needs_wal</span> <span class="pl-c1">=</span> true;
			<span class="pl-k">break</span>;
		<span class="pl-k">default</span>:
			<span class="pl-en">elog</span>(<span class="pl-c1">ERROR</span>, <span class="pl-s">"invalid relpersistence: %c"</span>, <span class="pl-s1">relpersistence</span>);
			<span class="pl-k">return</span> <span class="pl-c1">NULL</span>;		<span class="pl-c">/* placate compiler */</span>
	}

	<span class="pl-s1">srel</span> <span class="pl-c1">=</span> <span class="pl-en">smgropen</span>(<span class="pl-s1">rlocator</span>, <span class="pl-s1">backend</span>);
    <span class="pl-c">//创建主分支文件</span>
	<span class="pl-en">smgrcreate</span>(<span class="pl-s1">srel</span>, <span class="pl-c1">MAIN_FORKNUM</span>, false);

	<span class="pl-k">if</span> (<span class="pl-s1">needs_wal</span>)
		<span class="pl-en">log_smgrcreate</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">srel</span><span class="pl-c1">-&gt;</span><span class="pl-c1">smgr_rlocator</span>.<span class="pl-c1">locator</span>, <span class="pl-c1">MAIN_FORKNUM</span>);

	<span class="pl-c">/*</span>
<span class="pl-c">	 * Add the relation to the list of stuff to delete at abort, if we are</span>
<span class="pl-c">	 * asked to do so.</span>
<span class="pl-c">	 */</span>
	<span class="pl-k">if</span> (<span class="pl-s1">register_delete</span>)
	{
		<span class="pl-smi">PendingRelDelete</span> <span class="pl-c1">*</span><span class="pl-s1">pending</span>;

		<span class="pl-s1">pending</span> <span class="pl-c1">=</span> (<span class="pl-smi">PendingRelDelete</span> <span class="pl-c1">*</span>)
			<span class="pl-en">MemoryContextAlloc</span>(<span class="pl-s1">TopMemoryContext</span>, <span class="pl-k">sizeof</span>(<span class="pl-s1">PendingRelDelete</span>));
		<span class="pl-s1">pending</span><span class="pl-c1">-&gt;</span><span class="pl-c1">rlocator</span> <span class="pl-c1">=</span> <span class="pl-s1">rlocator</span>;
		<span class="pl-s1">pending</span><span class="pl-c1">-&gt;</span><span class="pl-c1">backend</span> <span class="pl-c1">=</span> <span class="pl-s1">backend</span>;
		<span class="pl-s1">pending</span><span class="pl-c1">-&gt;</span><span class="pl-c1">atCommit</span> <span class="pl-c1">=</span> false;	<span class="pl-c">/* delete if abort */</span>
		<span class="pl-s1">pending</span><span class="pl-c1">-&gt;</span><span class="pl-c1">nestLevel</span> <span class="pl-c1">=</span> <span class="pl-en">GetCurrentTransactionNestLevel</span>();
		<span class="pl-s1">pending</span><span class="pl-c1">-&gt;</span><span class="pl-c1">next</span> <span class="pl-c1">=</span> <span class="pl-s1">pendingDeletes</span>;
		<span class="pl-s1">pendingDeletes</span> <span class="pl-c1">=</span> <span class="pl-s1">pending</span>;
	}

	<span class="pl-k">if</span> (<span class="pl-s1">relpersistence</span> <span class="pl-c1">==</span> <span class="pl-c1">RELPERSISTENCE_PERMANENT</span> <span class="pl-c1">&amp;&amp;</span> !<span class="pl-en">XLogIsNeeded</span>())
	{
		<span class="pl-en">Assert</span>(<span class="pl-s1">backend</span> <span class="pl-c1">==</span> <span class="pl-s1">InvalidBackendId</span>);
		<span class="pl-en">AddPendingSync</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">rlocator</span>);
	}

	<span class="pl-k">return</span> <span class="pl-s1">srel</span>;
}</pre></div>
<p>涉及到外存管理那块太过细节的内容就不在此处展示了。</p>
<h2>其他工作</h2>
<p>在完成了文件创建之后，还有一些工作需要处理，比方说维护元数据（将相关信息插入pg<em>class，将表中的字段信息插入值pg</em>_attribute，相关依赖信息）、创建相关对象（同名数据类型以及对应的数组类型）和TOAST。</p>
<p>heap_create_with_catalog部分代码片段：</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">/*</span>
<span class="pl-c">	 * Decide whether to create a pg_type entry for the relation's rowtype.</span>
<span class="pl-c">	 * These types are made except where the use of a relation as such is an</span>
<span class="pl-c">	 * implementation detail: toast tables, sequences and indexes.</span>
<span class="pl-c">	 */</span>
	<span class="pl-k">if</span> (!(<span class="pl-s1">relkind</span> <span class="pl-c1">==</span> <span class="pl-c1">RELKIND_SEQUENCE</span> <span class="pl-c1">||</span>
		  <span class="pl-s1">relkind</span> <span class="pl-c1">==</span> <span class="pl-c1">RELKIND_TOASTVALUE</span> <span class="pl-c1">||</span>
		  <span class="pl-s1">relkind</span> <span class="pl-c1">==</span> <span class="pl-c1">RELKIND_INDEX</span> <span class="pl-c1">||</span>
		  <span class="pl-s1">relkind</span> <span class="pl-c1">==</span> <span class="pl-c1">RELKIND_PARTITIONED_INDEX</span>))
	{
		<span class="pl-smi">Oid</span>			<span class="pl-s1">new_array_oid</span>;
		<span class="pl-smi">ObjectAddress</span> <span class="pl-s1">new_type_addr</span>;
		<span class="pl-smi">char</span>	   <span class="pl-c1">*</span><span class="pl-s1">relarrayname</span>;

		<span class="pl-c">/*</span>
<span class="pl-c">		 * We'll make an array over the composite type, too.  For largely</span>
<span class="pl-c">		 * historical reasons, the array type's OID is assigned first.</span>
<span class="pl-c">		 */</span>
		<span class="pl-s1">new_array_oid</span> <span class="pl-c1">=</span> <span class="pl-en">AssignTypeArrayOid</span>();

		<span class="pl-c">/*</span>
<span class="pl-c">		 * Make the pg_type entry for the composite type.  The OID of the</span>
<span class="pl-c">		 * composite type can be preselected by the caller, but if reltypeid</span>
<span class="pl-c">		 * is InvalidOid, we'll generate a new OID for it.</span>
<span class="pl-c">		 *</span>
<span class="pl-c">		 * NOTE: we could get a unique-index failure here, in case someone</span>
<span class="pl-c">		 * else is creating the same type name in parallel but hadn't</span>
<span class="pl-c">		 * committed yet when we checked for a duplicate name above.</span>
<span class="pl-c">		 */</span>
		<span class="pl-s1">new_type_addr</span> <span class="pl-c1">=</span> <span class="pl-en">AddNewRelationType</span>(<span class="pl-s1">relname</span>,
										   <span class="pl-s1">relnamespace</span>,
										   <span class="pl-s1">relid</span>,
										   <span class="pl-s1">relkind</span>,
										   <span class="pl-s1">ownerid</span>,
										   <span class="pl-s1">reltypeid</span>,
										   <span class="pl-s1">new_array_oid</span>);
		<span class="pl-s1">new_type_oid</span> <span class="pl-c1">=</span> <span class="pl-s1">new_type_addr</span>.<span class="pl-c1">objectId</span>;
		<span class="pl-k">if</span> (<span class="pl-s1">typaddress</span>)
			<span class="pl-c1">*</span><span class="pl-s1">typaddress</span> <span class="pl-c1">=</span> <span class="pl-s1">new_type_addr</span>;

		<span class="pl-c">/* Now create the array type. */</span>
		<span class="pl-s1">relarrayname</span> <span class="pl-c1">=</span> <span class="pl-en">makeArrayTypeName</span>(<span class="pl-s1">relname</span>, <span class="pl-s1">relnamespace</span>);

		<span class="pl-en">TypeCreate</span>(<span class="pl-s1">new_array_oid</span>,	<span class="pl-c">/* force the type's OID to this */</span>
				   <span class="pl-s1">relarrayname</span>,	<span class="pl-c">/* Array type name */</span>
				   <span class="pl-s1">relnamespace</span>,	<span class="pl-c">/* Same namespace as parent */</span>
				   <span class="pl-s1">InvalidOid</span>,	<span class="pl-c">/* Not composite, no relationOid */</span>
				   <span class="pl-c1">0</span>,			<span class="pl-c">/* relkind, also N/A here */</span>
				   <span class="pl-s1">ownerid</span>,		<span class="pl-c">/* owner's ID */</span>
				   <span class="pl-c1">-1</span>,			<span class="pl-c">/* Internal size (varlena) */</span>
				   <span class="pl-c1">TYPTYPE_BASE</span>,	<span class="pl-c">/* Not composite - typelem is */</span>
				   <span class="pl-c1">TYPCATEGORY_ARRAY</span>,	<span class="pl-c">/* type-category (array) */</span>
				   false,		<span class="pl-c">/* array types are never preferred */</span>
				   <span class="pl-c1">DEFAULT_TYPDELIM</span>,	<span class="pl-c">/* default array delimiter */</span>
				   <span class="pl-c1">F_ARRAY_IN</span>,	<span class="pl-c">/* array input proc */</span>
				   <span class="pl-c1">F_ARRAY_OUT</span>, <span class="pl-c">/* array output proc */</span>
				   <span class="pl-c1">F_ARRAY_RECV</span>,	<span class="pl-c">/* array recv (bin) proc */</span>
				   <span class="pl-c1">F_ARRAY_SEND</span>,	<span class="pl-c">/* array send (bin) proc */</span>
				   <span class="pl-s1">InvalidOid</span>,	<span class="pl-c">/* typmodin procedure - none */</span>
				   <span class="pl-s1">InvalidOid</span>,	<span class="pl-c">/* typmodout procedure - none */</span>
				   <span class="pl-c1">F_ARRAY_TYPANALYZE</span>,	<span class="pl-c">/* array analyze procedure */</span>
				   <span class="pl-c1">F_ARRAY_SUBSCRIPT_HANDLER</span>,	<span class="pl-c">/* array subscript procedure */</span>
				   <span class="pl-s1">new_type_oid</span>,	<span class="pl-c">/* array element type - the rowtype */</span>
				   true,		<span class="pl-c">/* yes, this is an array type */</span>
				   <span class="pl-s1">InvalidOid</span>,	<span class="pl-c">/* this has no array type */</span>
				   <span class="pl-s1">InvalidOid</span>,	<span class="pl-c">/* domain base type - irrelevant */</span>
				   <span class="pl-c1">NULL</span>,		<span class="pl-c">/* default value - none */</span>
				   <span class="pl-c1">NULL</span>,		<span class="pl-c">/* default binary representation */</span>
				   false,		<span class="pl-c">/* passed by reference */</span>
				   <span class="pl-c1">TYPALIGN_DOUBLE</span>, <span class="pl-c">/* alignment - must be the largest! */</span>
				   <span class="pl-c1">TYPSTORAGE_EXTENDED</span>, <span class="pl-c">/* fully TOASTable */</span>
				   <span class="pl-c1">-1</span>,			<span class="pl-c">/* typmod */</span>
				   <span class="pl-c1">0</span>,			<span class="pl-c">/* array dimensions for typBaseType */</span>
				   false,		<span class="pl-c">/* Type NOT NULL */</span>
				   <span class="pl-s1">InvalidOid</span>); <span class="pl-c">/* rowtypes never have a collation */</span>

		<span class="pl-en">pfree</span>(<span class="pl-s1">relarrayname</span>);
	}
	<span class="pl-k">else</span>
	{
		<span class="pl-c">/* Caller should not be expecting a type to be created. */</span>
		<span class="pl-en">Assert</span>(<span class="pl-s1">reltypeid</span> <span class="pl-c1">==</span> <span class="pl-s1">InvalidOid</span>);
		<span class="pl-en">Assert</span>(<span class="pl-s1">typaddress</span> <span class="pl-c1">==</span> <span class="pl-c1">NULL</span>);

		<span class="pl-s1">new_type_oid</span> <span class="pl-c1">=</span> <span class="pl-s1">InvalidOid</span>;
	}

	<span class="pl-c">/*</span>
<span class="pl-c">	 * now create an entry in pg_class for the relation.</span>
<span class="pl-c">	 *</span>
<span class="pl-c">	 * NOTE: we could get a unique-index failure here, in case someone else is</span>
<span class="pl-c">	 * creating the same relation name in parallel but hadn't committed yet</span>
<span class="pl-c">	 * when we checked for a duplicate name above.</span>
<span class="pl-c">	 */</span>
	<span class="pl-en">AddNewRelationTuple</span>(<span class="pl-s1">pg_class_desc</span>,
						<span class="pl-s1">new_rel_desc</span>,
						<span class="pl-s1">relid</span>,
						<span class="pl-s1">new_type_oid</span>,
						<span class="pl-s1">reloftypeid</span>,
						<span class="pl-s1">ownerid</span>,
						<span class="pl-s1">relkind</span>,
						<span class="pl-s1">relfrozenxid</span>,
						<span class="pl-s1">relminmxid</span>,
						<span class="pl-en">PointerGetDatum</span>(<span class="pl-s1">relacl</span>),
						<span class="pl-s1">reloptions</span>);

	<span class="pl-c">/*</span>
<span class="pl-c">	 * now add tuples to pg_attribute for the attributes in our new relation.</span>
<span class="pl-c">	 */</span>
	<span class="pl-en">AddNewAttributeTuples</span>(<span class="pl-s1">relid</span>, <span class="pl-s1">new_rel_desc</span><span class="pl-c1">-&gt;</span><span class="pl-c1">rd_att</span>, <span class="pl-s1">relkind</span>);

	<span class="pl-c">/*</span>
<span class="pl-c">	 * Make a dependency link to force the relation to be deleted if its</span>
<span class="pl-c">	 * namespace is.  Also make a dependency link to its owner, as well as</span>
<span class="pl-c">	 * dependencies for any roles mentioned in the default ACL.</span>
<span class="pl-c">	 *</span>
<span class="pl-c">	 * For composite types, these dependencies are tracked for the pg_type</span>
<span class="pl-c">	 * entry, so we needn't record them here.  Likewise, TOAST tables don't</span>
<span class="pl-c">	 * need a namespace dependency (they live in a pinned namespace) nor an</span>
<span class="pl-c">	 * owner dependency (they depend indirectly through the parent table), nor</span>
<span class="pl-c">	 * should they have any ACL entries.  The same applies for extension</span>
<span class="pl-c">	 * dependencies.</span>
<span class="pl-c">	 *</span>
<span class="pl-c">	 * Also, skip this in bootstrap mode, since we don't make dependencies</span>
<span class="pl-c">	 * while bootstrapping.</span>
<span class="pl-c">	 */</span>
	<span class="pl-k">if</span> (<span class="pl-s1">relkind</span> <span class="pl-c1">!=</span> <span class="pl-c1">RELKIND_COMPOSITE_TYPE</span> <span class="pl-c1">&amp;&amp;</span>
		<span class="pl-s1">relkind</span> <span class="pl-c1">!=</span> <span class="pl-c1">RELKIND_TOASTVALUE</span> <span class="pl-c1">&amp;&amp;</span>
		!<span class="pl-en">IsBootstrapProcessingMode</span>())
	{
		<span class="pl-smi">ObjectAddress</span> <span class="pl-s1">myself</span>,
					<span class="pl-s1">referenced</span>;
		<span class="pl-smi">ObjectAddresses</span> <span class="pl-c1">*</span><span class="pl-s1">addrs</span>;

		<span class="pl-en">ObjectAddressSet</span>(<span class="pl-s1">myself</span>, <span class="pl-s1">RelationRelationId</span>, <span class="pl-s1">relid</span>);

		<span class="pl-en">recordDependencyOnOwner</span>(<span class="pl-s1">RelationRelationId</span>, <span class="pl-s1">relid</span>, <span class="pl-s1">ownerid</span>);

		<span class="pl-en">recordDependencyOnNewAcl</span>(<span class="pl-s1">RelationRelationId</span>, <span class="pl-s1">relid</span>, <span class="pl-c1">0</span>, <span class="pl-s1">ownerid</span>, <span class="pl-s1">relacl</span>);

		<span class="pl-en">recordDependencyOnCurrentExtension</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">myself</span>, false);

		<span class="pl-s1">addrs</span> <span class="pl-c1">=</span> <span class="pl-en">new_object_addresses</span>();

		<span class="pl-en">ObjectAddressSet</span>(<span class="pl-s1">referenced</span>, <span class="pl-s1">NamespaceRelationId</span>, <span class="pl-s1">relnamespace</span>);
		<span class="pl-en">add_exact_object_address</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">referenced</span>, <span class="pl-s1">addrs</span>);

		<span class="pl-k">if</span> (<span class="pl-s1">reloftypeid</span>)
		{
			<span class="pl-en">ObjectAddressSet</span>(<span class="pl-s1">referenced</span>, <span class="pl-s1">TypeRelationId</span>, <span class="pl-s1">reloftypeid</span>);
			<span class="pl-en">add_exact_object_address</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">referenced</span>, <span class="pl-s1">addrs</span>);
		}

		<span class="pl-c">/*</span>
<span class="pl-c">		 * Make a dependency link to force the relation to be deleted if its</span>
<span class="pl-c">		 * access method is.</span>
<span class="pl-c">		 *</span>
<span class="pl-c">		 * No need to add an explicit dependency for the toast table, as the</span>
<span class="pl-c">		 * main table depends on it.</span>
<span class="pl-c">		 */</span>
		<span class="pl-k">if</span> (<span class="pl-en">RELKIND_HAS_TABLE_AM</span>(<span class="pl-s1">relkind</span>) <span class="pl-c1">&amp;&amp;</span> <span class="pl-s1">relkind</span> <span class="pl-c1">!=</span> <span class="pl-c1">RELKIND_TOASTVALUE</span>)
		{
			<span class="pl-en">ObjectAddressSet</span>(<span class="pl-s1">referenced</span>, <span class="pl-s1">AccessMethodRelationId</span>, <span class="pl-s1">accessmtd</span>);
			<span class="pl-en">add_exact_object_address</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">referenced</span>, <span class="pl-s1">addrs</span>);
		}

		<span class="pl-en">record_object_address_dependencies</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">myself</span>, <span class="pl-s1">addrs</span>, <span class="pl-c1">DEPENDENCY_NORMAL</span>);
		<span class="pl-en">free_object_addresses</span>(<span class="pl-s1">addrs</span>);
	}

	<span class="pl-c">/* Post creation hook for new relation */</span>
	<span class="pl-en">InvokeObjectPostCreateHookArg</span>(<span class="pl-s1">RelationRelationId</span>, <span class="pl-s1">relid</span>, <span class="pl-c1">0</span>, <span class="pl-s1">is_internal</span>);</pre></div>
<p>ProcessUtilitySlow部分代码片段</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-k">if</span> (<span class="pl-en">IsA</span>(<span class="pl-s1">stmt</span>, <span class="pl-s1">CreateStmt</span>))
{
  <span class="pl-smi">CreateStmt</span> <span class="pl-c1">*</span><span class="pl-s1">cstmt</span> <span class="pl-c1">=</span> (<span class="pl-smi">CreateStmt</span> <span class="pl-c1">*</span>) <span class="pl-s1">stmt</span>;
  <span class="pl-smi">Datum</span>   <span class="pl-s1">toast_options</span>;
  <span class="pl-k">static</span> <span class="pl-smi">char</span> <span class="pl-c1">*</span><span class="pl-s1">validnsps</span>[] <span class="pl-c1">=</span> <span class="pl-c1">HEAP_RELOPT_NAMESPACES</span>;

  <span class="pl-c">/* Remember transformed RangeVar for LIKE */</span>
  <span class="pl-s1">table_rv</span> <span class="pl-c1">=</span> <span class="pl-s1">cstmt</span><span class="pl-c1">-&gt;</span><span class="pl-c1">relation</span>;

  <span class="pl-c">/* Create the table itself */</span>
  <span class="pl-s1">address</span> <span class="pl-c1">=</span> <span class="pl-en">DefineRelation</span>(<span class="pl-s1">cstmt</span>,
               <span class="pl-c1">RELKIND_RELATION</span>,
               <span class="pl-s1">InvalidOid</span>, <span class="pl-c1">NULL</span>,
               <span class="pl-s1">queryString</span>);
  <span class="pl-en">EventTriggerCollectSimpleCommand</span>(<span class="pl-s1">address</span>,
                   <span class="pl-s1">secondaryObject</span>,
                   <span class="pl-s1">stmt</span>);

  <span class="pl-c">/*</span>
<span class="pl-c">   * Let NewRelationCreateToastTable decide if this</span>
<span class="pl-c">   * one needs a secondary relation too.</span>
<span class="pl-c">   */</span>
  <span class="pl-en">CommandCounterIncrement</span>();

  <span class="pl-c">/*</span>
<span class="pl-c">   * parse and validate reloptions for the toast</span>
<span class="pl-c">   * table</span>
<span class="pl-c">   */</span>
  <span class="pl-s1">toast_options</span> <span class="pl-c1">=</span> <span class="pl-en">transformRelOptions</span>((<span class="pl-smi">Datum</span>) <span class="pl-c1">0</span>,
                    <span class="pl-s1">cstmt</span><span class="pl-c1">-&gt;</span><span class="pl-c1">options</span>,
                    <span class="pl-s">"toast"</span>,
                    <span class="pl-s1">validnsps</span>,
                    true,
                    false);
  (<span class="pl-smi">void</span>) <span class="pl-en">heap_reloptions</span>(<span class="pl-c1">RELKIND_TOASTVALUE</span>,
               <span class="pl-s1">toast_options</span>,
               true);

  <span class="pl-en">NewRelationCreateToastTable</span>(<span class="pl-s1">address</span>.<span class="pl-c1">objectId</span>,
                <span class="pl-s1">toast_options</span>);
}</pre></div>
<p>还有很多细节的内容，感兴趣的同学可以自己动手调试着玩玩。</p>
<h2>验证一下最终结果</h2>
<div class="highlight highlight-source-sql"><pre class="notranslate">postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> SELECT pg_relation_filepath('test_unlogged_table');</span>
 pg_relation_filepath 
<span class="pl-c"><span class="pl-c">--</span>--------------------</span>
 base<span class="pl-k">/</span><span class="pl-c1">5</span><span class="pl-k">/</span><span class="pl-c1">157247</span>
(<span class="pl-c1">1</span> row)

postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> \! ls $PGDATA/base/5/157247* -al</span>
<span class="pl-k">-</span>rw<span class="pl-c"><span class="pl-c">--</span>----- 1 postgres postgres 0  9月  2 17:41 /data/16/base/5/157247</span>
<span class="pl-k">-</span>rw<span class="pl-c"><span class="pl-c">--</span>----- 1 postgres postgres 0  9月  2 17:41 /data/16/base/5/157247_init</span>
postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> SELECT * FROM PG_CLASS WHERE relname = 'test_unlogged_table' \gx</span>
<span class="pl-k">-</span>[ RECORD <span class="pl-c1">1</span> ]<span class="pl-c"><span class="pl-c">--</span>-----+--------------------</span>
<span class="pl-k">oid</span>                 | <span class="pl-c1">157247</span>
relname             | test_unlogged_table
relnamespace        | <span class="pl-c1">2200</span>
reltype             | <span class="pl-c1">157249</span>
reloftype           | <span class="pl-c1">0</span>
relowner            | <span class="pl-c1">10</span>
relam               | <span class="pl-c1">2</span>
relfilenode         | <span class="pl-c1">157247</span>
reltablespace       | <span class="pl-c1">0</span>
relpages            | <span class="pl-c1">0</span>
reltuples           | <span class="pl-k">-</span><span class="pl-c1">1</span>
relallvisible       | <span class="pl-c1">0</span>
reltoastrelid       | <span class="pl-c1">0</span>
relhasindex         | f
relisshared         | f
relpersistence      | u
relkind             | r
relnatts            | <span class="pl-c1">1</span>
relchecks           | <span class="pl-c1">0</span>
relhasrules         | f
relhastriggers      | f
relhassubclass      | f
relrowsecurity      | f
relforcerowsecurity | f
relispopulated      | t
relreplident        | d
relispartition      | f
relrewrite          | <span class="pl-c1">0</span>
relfrozenxid        | <span class="pl-c1">7293</span>
relminmxid          | <span class="pl-c1">1</span>
relacl              | 
reloptions          | 
relpartbound        | 

postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> </span></pre></div>
<h1>玩一玩初始分支</h1>
<p>让我们来尝试着删除UNLOGGED TABLE的主分支文件，然后重启，看看是否能够进行查询</p>
<div class="highlight highlight-source-sql"><pre class="notranslate">postgres@zxm<span class="pl-k">-</span>VMware<span class="pl-k">-</span>Virtual<span class="pl-k">-</span>Platform:~$ psql
psql (<span class="pl-c1">16</span>.<span class="pl-c1">10</span>)
Type <span class="pl-s"><span class="pl-pds">"</span>help<span class="pl-pds">"</span></span> for help.

postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> -- 创建测试表</span>
postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> CREATE UNLOGGED TABLE test_unlogged_table(a int);</span>
CREATE TABLE
postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> -- 获取主分支文件路径  </span>
postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> SELECT pg_relation_filepath('test_unlogged_table');</span>
 pg_relation_filepath 
<span class="pl-c"><span class="pl-c">--</span>--------------------</span>
 base<span class="pl-k">/</span><span class="pl-c1">5</span><span class="pl-k">/</span><span class="pl-c1">173637</span>
(<span class="pl-c1">1</span> row)

postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> \q</span>
postgres@zxm<span class="pl-k">-</span>VMware<span class="pl-k">-</span>Virtual<span class="pl-k">-</span>Platform:~$ rm $PGDATA<span class="pl-k">/</span>base<span class="pl-k">/</span><span class="pl-c1">5</span><span class="pl-k">/</span><span class="pl-c1">173637</span>
postgres@zxm<span class="pl-k">-</span>VMware<span class="pl-k">-</span>Virtual<span class="pl-k">-</span>Platform:~$ ls $PGDATA<span class="pl-k">/</span>base<span class="pl-k">/</span><span class="pl-c1">5</span><span class="pl-k">/</span><span class="pl-c1">173637</span><span class="pl-k">*</span> <span class="pl-k">-</span>al 
<span class="pl-k">-</span>rw<span class="pl-c"><span class="pl-c">--</span>----- 1 postgres postgres 0  9月  2 19:17 /data/16/base/5/173637_init</span>
postgres@zxm<span class="pl-k">-</span>VMware<span class="pl-k">-</span>Virtual<span class="pl-k">-</span>Platform:~$ pg_ctl restart
waiting for server to shut down.... done
server stopped
waiting for server to start....<span class="pl-c1">2025</span><span class="pl-k">-</span><span class="pl-c1">09</span><span class="pl-k">-</span><span class="pl-c1">02</span> <span class="pl-c1">19</span>:<span class="pl-c1">18</span>:<span class="pl-c1">15</span>.<span class="pl-c1">616</span> CST [<span class="pl-c1">12493</span>] LOG:  redirecting log output to logging collector process
<span class="pl-c1">2025</span><span class="pl-k">-</span><span class="pl-c1">09</span><span class="pl-k">-</span><span class="pl-c1">02</span> <span class="pl-c1">19</span>:<span class="pl-c1">18</span>:<span class="pl-c1">15</span>.<span class="pl-c1">616</span> CST [<span class="pl-c1">12493</span>] HINT:  Future log output will appear <span class="pl-k">in</span> directory <span class="pl-s"><span class="pl-pds">"</span>log<span class="pl-pds">"</span></span>.
 done
server started
postgres@zxm<span class="pl-k">-</span>VMware<span class="pl-k">-</span>Virtual<span class="pl-k">-</span>Platform:~$ psql
psql (<span class="pl-c1">16</span>.<span class="pl-c1">10</span>)
Type <span class="pl-s"><span class="pl-pds">"</span>help<span class="pl-pds">"</span></span> for help.

postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> select * from test_unlogged_table;</span>
 a 
<span class="pl-c"><span class="pl-c">--</span>-</span>
(<span class="pl-c1">0</span> rows)

postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> SELECT pg_relation_filepath('test_unlogged_table');</span>
 pg_relation_filepath 
<span class="pl-c"><span class="pl-c">--</span>--------------------</span>
 base<span class="pl-k">/</span><span class="pl-c1">5</span><span class="pl-k">/</span><span class="pl-c1">173637</span>
(<span class="pl-c1">1</span> row)

postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> </span></pre></div>
<p>可以看到是可以的，如果我们在退出前，在运行一下checkpoint呢？</p>
<div class="highlight highlight-source-sql"><pre class="notranslate">postgres@zxm<span class="pl-k">-</span>VMware<span class="pl-k">-</span>Virtual<span class="pl-k">-</span>Platform:~$ psql
psql (<span class="pl-c1">16</span>.<span class="pl-c1">10</span>)
Type <span class="pl-s"><span class="pl-pds">"</span>help<span class="pl-pds">"</span></span> for help.

postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> -- 创建测试表</span>
postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> CREATE UNLOGGED TABLE test_unlogged_table(a int);</span>
CREATE TABLE
postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> -- 获取主分支文件路径  </span>
postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> SELECT pg_relation_filepath('test_unlogged_table');</span>
 pg_relation_filepath 
<span class="pl-c"><span class="pl-c">--</span>--------------------</span>
 base<span class="pl-k">/</span><span class="pl-c1">5</span><span class="pl-k">/</span><span class="pl-c1">181829</span>
(<span class="pl-c1">1</span> row)

postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> checkpoint;</span>
CHECKPOINT
postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> \q</span>
postgres@zxm<span class="pl-k">-</span>VMware<span class="pl-k">-</span>Virtual<span class="pl-k">-</span>Platform:~$ rm $PGDATA<span class="pl-k">/</span>base<span class="pl-k">/</span><span class="pl-c1">5</span><span class="pl-k">/</span><span class="pl-c1">181829</span>
postgres@zxm<span class="pl-k">-</span>VMware<span class="pl-k">-</span>Virtual<span class="pl-k">-</span>Platform:~$ ls $PGDATA<span class="pl-k">/</span>base<span class="pl-k">/</span><span class="pl-c1">5</span><span class="pl-k">/</span><span class="pl-c1">181829</span><span class="pl-k">*</span> <span class="pl-k">-</span>al
<span class="pl-k">-</span>rw<span class="pl-c"><span class="pl-c">--</span>----- 1 postgres postgres 0  9月  2 19:19 /data/16/base/5/181829_init</span>
postgres@zxm<span class="pl-k">-</span>VMware<span class="pl-k">-</span>Virtual<span class="pl-k">-</span>Platform:~$ pg_ctl restart
waiting for server to shut down.... done
server stopped
waiting for server to start....<span class="pl-c1">2025</span><span class="pl-k">-</span><span class="pl-c1">09</span><span class="pl-k">-</span><span class="pl-c1">02</span> <span class="pl-c1">19</span>:<span class="pl-c1">19</span>:<span class="pl-c1">59</span>.<span class="pl-c1">113</span> CST [<span class="pl-c1">12510</span>] LOG:  redirecting log output to logging collector process
<span class="pl-c1">2025</span><span class="pl-k">-</span><span class="pl-c1">09</span><span class="pl-k">-</span><span class="pl-c1">02</span> <span class="pl-c1">19</span>:<span class="pl-c1">19</span>:<span class="pl-c1">59</span>.<span class="pl-c1">113</span> CST [<span class="pl-c1">12510</span>] HINT:  Future log output will appear <span class="pl-k">in</span> directory <span class="pl-s"><span class="pl-pds">"</span>log<span class="pl-pds">"</span></span>.
 done
server started
postgres@zxm<span class="pl-k">-</span>VMware<span class="pl-k">-</span>Virtual<span class="pl-k">-</span>Platform:~$ psql
psql (<span class="pl-c1">16</span>.<span class="pl-c1">10</span>)
Type <span class="pl-s"><span class="pl-pds">"</span>help<span class="pl-pds">"</span></span> for help.

postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> select * from test_unlogged_table;</span>
ERROR:  could not open file <span class="pl-s"><span class="pl-pds">"</span>base/5/181829<span class="pl-pds">"</span></span>: 没有那个文件或目录
postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> </span></pre></div>
<p>可以看到就不行了，这是为什么呢？<br>
关键在于<strong>Recovery</strong>，这里就不细说了，可以考虑看看代码或者将日志级别调低查看一下，就能明白了。<br>
同时那现在怎么办呢？查询不了了<br>
这里有两个解决方法，一个就是kill一下会话，触发异常，另一个就是手动创建一下文件即可</p>
<div class="highlight highlight-source-sql"><pre class="notranslate">postgres@zxm<span class="pl-k">-</span>VMware<span class="pl-k">-</span>Virtual<span class="pl-k">-</span>Platform:~$ psql
psql (<span class="pl-c1">16</span>.<span class="pl-c1">10</span>)
Type <span class="pl-s"><span class="pl-pds">"</span>help<span class="pl-pds">"</span></span> for help.

postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> select * from test_unlogged_table;</span>
ERROR:  could not open file <span class="pl-s"><span class="pl-pds">"</span>base/5/181829<span class="pl-pds">"</span></span>: 没有那个文件或目录
postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> \! touch $PGDATA/base/5/181829</span>
postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> select * from test_unlogged_table;</span>
 a 
<span class="pl-c"><span class="pl-c">--</span>-</span>
(<span class="pl-c1">0</span> rows)

postgres<span class="pl-k">=</span><span class="pl-c"><span class="pl-c">#</span> </span></pre></div>
<p>相关"恢复"代码如下，其实就是unlink，然后create，感兴趣的朋友可以看看</p>
<div class="highlight highlight-source-sql"><pre class="notranslate">static void
ResetUnloggedRelationsInDbspaceDir(const <span class="pl-k">char</span> <span class="pl-k">*</span>dbspacedirname, <span class="pl-k">int</span> op)
{
	DIR		   <span class="pl-k">*</span>dbspace_dir;
	struct dirent <span class="pl-k">*</span>de;
	<span class="pl-k">char</span>		rm_path[MAXPGPATH <span class="pl-k">*</span> <span class="pl-c1">2</span>];

	<span class="pl-c"><span class="pl-c">/*</span> Caller must specify at least one operation. <span class="pl-c">*/</span></span>
	Assert((op &amp; (UNLOGGED_RELATION_CLEANUP | UNLOGGED_RELATION_INIT)) <span class="pl-k">!=</span> <span class="pl-c1">0</span>);

	<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">	 * Cleanup is a two-pass operation.  First, we go through and identify all</span>
<span class="pl-c">	 * the files with init forks.  Then, we go through again and nuke</span>
<span class="pl-c">	 * everything with the same OID except the init fork.</span>
<span class="pl-c">	 <span class="pl-c">*/</span></span>
	if ((op &amp; UNLOGGED_RELATION_CLEANUP) <span class="pl-k">!=</span> <span class="pl-c1">0</span>)
	{
		HTAB	   <span class="pl-k">*</span>hash;
		HASHCTL		ctl;

		<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">		 * It's possible that someone could create a ton of unlogged relations</span>
<span class="pl-c">		 * in the same database &amp; tablespace, so we'd better use a hash table</span>
<span class="pl-c">		 * rather than an array or linked list to keep track of which files</span>
<span class="pl-c">		 * need to be reset.  Otherwise, this cleanup operation would be</span>
<span class="pl-c">		 * O(n^2).</span>
<span class="pl-c">		 <span class="pl-c">*/</span></span>
		<span class="pl-c1">ctl</span>.<span class="pl-c1">keysize</span> <span class="pl-k">=</span> sizeof(<span class="pl-k">Oid</span>);
		<span class="pl-c1">ctl</span>.<span class="pl-c1">entrysize</span> <span class="pl-k">=</span> sizeof(unlogged_relation_entry);
		<span class="pl-c1">ctl</span>.<span class="pl-c1">hcxt</span> <span class="pl-k">=</span> CurrentMemoryContext;
		hash <span class="pl-k">=</span> hash_create(<span class="pl-s"><span class="pl-pds">"</span>unlogged relation OIDs<span class="pl-pds">"</span></span>, <span class="pl-c1">32</span>, &amp;ctl,
						   HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);

		<span class="pl-c"><span class="pl-c">/*</span> Scan the directory. <span class="pl-c">*/</span></span>
		dbspace_dir <span class="pl-k">=</span> AllocateDir(dbspacedirname);
		while ((de <span class="pl-k">=</span> ReadDir(dbspace_dir, dbspacedirname)) <span class="pl-k">!=</span> <span class="pl-k">NULL</span>)
		{
			ForkNumber	forkNum;
			<span class="pl-k">int</span>			relnumchars;
			unlogged_relation_entry ent;

			<span class="pl-c"><span class="pl-c">/*</span> Skip anything that doesn't look like a relation data file. <span class="pl-c">*/</span></span>
			if (!parse_filename_for_nontemp_relation(de<span class="pl-k">-</span><span class="pl-k">&gt;</span>d_name, &amp;relnumchars,
													 &amp;forkNum))
				continue;

			<span class="pl-c"><span class="pl-c">/*</span> Also skip it unless this is the init fork. <span class="pl-c">*/</span></span>
			if (forkNum <span class="pl-k">!=</span> INIT_FORKNUM)
				continue;

			<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">			 * Put the OID portion of the name into the hash table, if it</span>
<span class="pl-c">			 * isn't already.</span>
<span class="pl-c">			 <span class="pl-c">*/</span></span>
			<span class="pl-c1">ent</span>.<span class="pl-c1">reloid</span> <span class="pl-k">=</span> atooid(de<span class="pl-k">-</span><span class="pl-k">&gt;</span>d_name);
			(void) hash_search(hash, &amp;ent, HASH_ENTER, <span class="pl-k">NULL</span>);
		}

		<span class="pl-c"><span class="pl-c">/*</span> Done with the first pass. <span class="pl-c">*/</span></span>
		FreeDir(dbspace_dir);

		<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">		 * If we didn't find any init forks, there's no point in continuing;</span>
<span class="pl-c">		 * we can bail out now.</span>
<span class="pl-c">		 <span class="pl-c">*/</span></span>
		if (hash_get_num_entries(hash) <span class="pl-k">==</span> <span class="pl-c1">0</span>)
		{
			hash_destroy(hash);
			return;
		}

		<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">		 * Now, make a second pass and remove anything that matches.</span>
<span class="pl-c">		 <span class="pl-c">*/</span></span>
		dbspace_dir <span class="pl-k">=</span> AllocateDir(dbspacedirname);
		while ((de <span class="pl-k">=</span> ReadDir(dbspace_dir, dbspacedirname)) <span class="pl-k">!=</span> <span class="pl-k">NULL</span>)
		{
			ForkNumber	forkNum;
			<span class="pl-k">int</span>			relnumchars;
			unlogged_relation_entry ent;

			<span class="pl-c"><span class="pl-c">/*</span> Skip anything that doesn't look like a relation data file. <span class="pl-c">*/</span></span>
			if (!parse_filename_for_nontemp_relation(de<span class="pl-k">-</span><span class="pl-k">&gt;</span>d_name, &amp;relnumchars,
													 &amp;forkNum))
				continue;

			<span class="pl-c"><span class="pl-c">/*</span> We never remove the init fork. <span class="pl-c">*/</span></span>
			if (forkNum <span class="pl-k">==</span> INIT_FORKNUM)
				continue;

			<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">			 * See whether the OID portion of the name shows up in the hash</span>
<span class="pl-c">			 * table.  If so, nuke it!</span>
<span class="pl-c">			 <span class="pl-c">*/</span></span>
			<span class="pl-c1">ent</span>.<span class="pl-c1">reloid</span> <span class="pl-k">=</span> atooid(de<span class="pl-k">-</span><span class="pl-k">&gt;</span>d_name);
			if (hash_search(hash, &amp;ent, HASH_FIND, <span class="pl-k">NULL</span>))
			{
				snprintf(rm_path, sizeof(rm_path), <span class="pl-s"><span class="pl-pds">"</span>%s/%s<span class="pl-pds">"</span></span>,
						 dbspacedirname, de<span class="pl-k">-</span><span class="pl-k">&gt;</span>d_name);
				if (unlink(rm_path) <span class="pl-k">&lt;</span> <span class="pl-c1">0</span>)
					ereport(ERROR,
							(errcode_for_file_access(),
							 errmsg(<span class="pl-s"><span class="pl-pds">"</span>could not remove file \<span class="pl-pds">"</span></span>%s\<span class="pl-s"><span class="pl-pds">"</span>: %m<span class="pl-pds">"</span></span>,
									rm_path)));
				else
					elog(DEBUG2, <span class="pl-s"><span class="pl-pds">"</span>unlinked file \<span class="pl-pds">"</span></span>%s\<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>, rm_path);
			}
		}

		<span class="pl-c"><span class="pl-c">/*</span> Cleanup is complete. <span class="pl-c">*/</span></span>
		FreeDir(dbspace_dir);
		hash_destroy(hash);
	}

	<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">	 * Initialization happens after cleanup is complete: we copy each init</span>
<span class="pl-c">	 * fork file to the corresponding main fork file.  Note that if we are</span>
<span class="pl-c">	 * asked to do both cleanup and init, we may never get here: if the</span>
<span class="pl-c">	 * cleanup code determines that there are no init forks in this dbspace,</span>
<span class="pl-c">	 * it will return before we get to this point.</span>
<span class="pl-c">	 <span class="pl-c">*/</span></span>
	if ((op &amp; UNLOGGED_RELATION_INIT) <span class="pl-k">!=</span> <span class="pl-c1">0</span>)
	{
		<span class="pl-c"><span class="pl-c">/*</span> Scan the directory. <span class="pl-c">*/</span></span>
		dbspace_dir <span class="pl-k">=</span> AllocateDir(dbspacedirname);
		while ((de <span class="pl-k">=</span> ReadDir(dbspace_dir, dbspacedirname)) <span class="pl-k">!=</span> <span class="pl-k">NULL</span>)
		{
			ForkNumber	forkNum;
			<span class="pl-k">int</span>			relnumchars;
			<span class="pl-k">char</span>		relnumbuf[OIDCHARS <span class="pl-k">+</span> <span class="pl-c1">1</span>];
			<span class="pl-k">char</span>		srcpath[MAXPGPATH <span class="pl-k">*</span> <span class="pl-c1">2</span>];
			<span class="pl-k">char</span>		dstpath[MAXPGPATH];

			<span class="pl-c"><span class="pl-c">/*</span> Skip anything that doesn't look like a relation data file. <span class="pl-c">*/</span></span>
			if (!parse_filename_for_nontemp_relation(de<span class="pl-k">-</span><span class="pl-k">&gt;</span>d_name, &amp;relnumchars,
													 &amp;forkNum))
				continue;

			<span class="pl-c"><span class="pl-c">/*</span> Also skip it unless this is the init fork. <span class="pl-c">*/</span></span>
			if (forkNum <span class="pl-k">!=</span> INIT_FORKNUM)
				continue;

			<span class="pl-c"><span class="pl-c">/*</span> Construct source pathname. <span class="pl-c">*/</span></span>
			snprintf(srcpath, sizeof(srcpath), <span class="pl-s"><span class="pl-pds">"</span>%s/%s<span class="pl-pds">"</span></span>,
					 dbspacedirname, de<span class="pl-k">-</span><span class="pl-k">&gt;</span>d_name);

			<span class="pl-c"><span class="pl-c">/*</span> Construct destination pathname. <span class="pl-c">*/</span></span>
			memcpy(relnumbuf, de<span class="pl-k">-</span><span class="pl-k">&gt;</span>d_name, relnumchars);
			relnumbuf[relnumchars] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\0</span><span class="pl-pds">'</span></span>;
			snprintf(dstpath, sizeof(dstpath), <span class="pl-s"><span class="pl-pds">"</span>%s/%s%s<span class="pl-pds">"</span></span>,
					 dbspacedirname, relnumbuf, de<span class="pl-k">-</span><span class="pl-k">&gt;</span>d_name <span class="pl-k">+</span> relnumchars <span class="pl-k">+</span> <span class="pl-c1">1</span> <span class="pl-k">+</span>
					 strlen(forkNames[INIT_FORKNUM]));

			<span class="pl-c"><span class="pl-c">/*</span> OK, we're ready to perform the actual copy. <span class="pl-c">*/</span></span>
			elog(DEBUG2, <span class="pl-s"><span class="pl-pds">"</span>copying %s to %s<span class="pl-pds">"</span></span>, srcpath, dstpath);
			copy_file(srcpath, dstpath);
		}

		FreeDir(dbspace_dir);

		<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">		 * copy_file() above has already called pg_flush_data() on the files</span>
<span class="pl-c">		 * it created. Now we need to fsync those files, because a checkpoint</span>
<span class="pl-c">		 * won't do it for us while we're in recovery. We do this in a</span>
<span class="pl-c">		 * separate pass to allow the kernel to perform all the flushes</span>
<span class="pl-c">		 * (especially the metadata ones) at once.</span>
<span class="pl-c">		 <span class="pl-c">*/</span></span>
		dbspace_dir <span class="pl-k">=</span> AllocateDir(dbspacedirname);
		while ((de <span class="pl-k">=</span> ReadDir(dbspace_dir, dbspacedirname)) <span class="pl-k">!=</span> <span class="pl-k">NULL</span>)
		{
			ForkNumber	forkNum;
			<span class="pl-k">int</span>			relnumchars;
			<span class="pl-k">char</span>		relnumbuf[OIDCHARS <span class="pl-k">+</span> <span class="pl-c1">1</span>];
			<span class="pl-k">char</span>		mainpath[MAXPGPATH];

			<span class="pl-c"><span class="pl-c">/*</span> Skip anything that doesn't look like a relation data file. <span class="pl-c">*/</span></span>
			if (!parse_filename_for_nontemp_relation(de<span class="pl-k">-</span><span class="pl-k">&gt;</span>d_name, &amp;relnumchars,
													 &amp;forkNum))
				continue;

			<span class="pl-c"><span class="pl-c">/*</span> Also skip it unless this is the init fork. <span class="pl-c">*/</span></span>
			if (forkNum <span class="pl-k">!=</span> INIT_FORKNUM)
				continue;

			<span class="pl-c"><span class="pl-c">/*</span> Construct main fork pathname. <span class="pl-c">*/</span></span>
			memcpy(relnumbuf, de<span class="pl-k">-</span><span class="pl-k">&gt;</span>d_name, relnumchars);
			relnumbuf[relnumchars] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\0</span><span class="pl-pds">'</span></span>;
			snprintf(mainpath, sizeof(mainpath), <span class="pl-s"><span class="pl-pds">"</span>%s/%s%s<span class="pl-pds">"</span></span>,
					 dbspacedirname, relnumbuf, de<span class="pl-k">-</span><span class="pl-k">&gt;</span>d_name <span class="pl-k">+</span> relnumchars <span class="pl-k">+</span> <span class="pl-c1">1</span> <span class="pl-k">+</span>
					 strlen(forkNames[INIT_FORKNUM]));

			fsync_fname(mainpath, false);
		}

		FreeDir(dbspace_dir);

		<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">		 * Lastly, fsync the database directory itself, ensuring the</span>
<span class="pl-c">		 * filesystem remembers the file creations and deletions we've done.</span>
<span class="pl-c">		 * We don't bother with this during a call that does only</span>
<span class="pl-c">		 * UNLOGGED_RELATION_CLEANUP, because if recovery crashes before we</span>
<span class="pl-c">		 * get to doing UNLOGGED_RELATION_INIT, we'll redo the cleanup step</span>
<span class="pl-c">		 * too at the next startup attempt.</span>
<span class="pl-c">		 <span class="pl-c">*/</span></span>
		fsync_fname(dbspacedirname, true);
	}
}</pre></div>
<p>还有一件事，最好不要随便学我这样子玩，去删除别的表的物理文件😀</p></div>
<div style="font-size:small;margin-top:8px;float:right;">❤️ 转载文章请注明出处，谢谢！❤️</div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://Z-Xiao-M.github.io/github.io">包里装着个卡比兽</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if("08/31/2025"!=""){
    var startSite=new Date("08/31/2025");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","Z-Xiao-M/github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>


</html>
